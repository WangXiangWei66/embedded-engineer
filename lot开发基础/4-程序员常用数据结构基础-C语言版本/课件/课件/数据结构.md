# 一、数据结构的概述

## 1.1 什么是数据结构

* N.沃思（Niklaus Wirth）教授提出：**程序 = 数据结构 + 算法**
* **数据结构：计算机存储、组织数据的方式**
* **算法：处理数据的方式**

## 1.2 为什么要学习数据结构

1. 掌握了数据的各种存储和组织方式的特点后，在实际的开发工作中我们可以根据实际需求选择合适的数据结构对数据进行存储，从而大大提高程序的运行效率。例如，在存储学生信息时因为学生人数为动态的所以可以选择使用链表对学生信息进行存储而不选择数组。在对一个目录进行检索时为了保存各个目录以及文件之间的层次关系可以选择树这种数据结构。
2. 掌握其他技术的实现原理。数据结构在操作系统、数据库、框架开发中被大量应用。例如：数据库的索引可以使用哈希、B树等，每种索引都有不同的实现、不同的效率和不同的应用场景，良好的数据结构基础可以支撑我们在实际应用中能够选择最合适的数据结构进行使用。

## 1.3 基本概念和术语

**1、数据**

数据（data）：所有能够输入到计算机中去的描述客观事物的符号。

* **数值型数据**： 表示数量，由数字、小数点、正负号和表示乘幂的字母E组成。数值型的数据是不能包含文本的，必须是数值
* **非数值型数据**：如文字、图像、声音等的计算机应用领域

**2、数据元素**

数据元素（data element）：数据的基本单位，也称之为结点（node）或者记录（record）

**3、数据对象**

数据对象（data object）：相同特性数据元素的集合，是数据的一个子集。

* 整型数据对象：所有正负整数的集合，其中的每一个整数就是一个数据元素

## 1.4 数据结构的分类

传统上，我们可以把数据结构分为逻辑结构和物理结构两大类：

* **逻辑结构分类**：逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题

  * **集合结构**：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/670e1a346c3e4637bcf8a80526bd5d97.png)
  * **线性结构**：线性结构中的数据元素之间存在一对一的关系![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/e8bb4d5155484b6780ba1590cbaebd9f.png)
  * **树形结构**：树形结构中的数据元素之间存在一对多的层次关系![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/aefd800fb6994d679debed584459209d.png)
  * **图形结构**：图形结构的数据元素是多对多的关系![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/36062b73bed24735abc3374b81b5ada5.png)
* **物理结构分类**：逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构（实际存储结构），也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。

  * **顺序存储结构**：**把数据元素放到地址连续的存储单元里面**，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/ad277ae3b5ed4f02aefe6b5a0a6c74cf.png)
  * **链式存储结构**：**把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的**。此时，数据元素之间并不能反映元素间的逻辑关系，因此**在链式存储结构中引进了一个指针存放数据元素的地址**，这样通过地址就可以找到相关联数据元素的位置。![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/a04749fd584d45729770e38df380ecec.png)

## 1.5 算法分析

### 1.5.1 算法的时间复杂度分析

# 二、线性表

## 2.1 线性结构概述

**1、线性表是一种典型的线性结构**：则有且仅有一个**开始结点**和一个**终端结点**，并且所有结点都最多只有一个**直接前趋**和一个**直接后继。**

**2、线性结构表达式**：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/2fae0630fd1544b384f74c434ef87b24.png)

**3、线性结构特点**:

* 只有一个首结点和尾结点
* 除首尾结点外，其他结点只有一个直接前驱和一个直接后继

简言之，线性结构反映结点间的逻辑关系是**一对一**的。

4、线性结构包括**线性表、堆栈、队列、字符串、数组**等等。

## 2.2 线性表的定义

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/7bb1a18cbbb849409727cc0d7532dd50.png)

如果把线性表用数学语言来定义，则可以表示为(a1,...ai-1,ai,ai+1,...an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai的后继元素。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/a07d47433e704f9785a4cb4b6b4c3ae7.png)

## 2.3 线性表的分类

线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把**线性表分为顺序表和链表。**

**线性表的基本操作：**

* **初始化**
* **取值**
* **查找**
* **插入**
* **删除**

### 2.3.1 顺序表

#### 2.3.1.1 顺序表的基本概念

顺序表是在计算机内存中以**数组**的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/d15e9980d53247009e6f3634f901cb88.png)

顺序表就是数组吗？不是的，顺序表只是体现了数据的存储特征而已，我们在实现顺序表时可以使用数组存储顺序表中的数据，顺序表还具有其他的特征例如容量、实际存储的元素的个数等。因此，我们可以定义一个结构体用来描述顺序表。

```
typedef int ElemType;
typedef unsigned int uint;
typedef struct {
	ElemType *elem; //顺序表中存储数据的空间，思考：为什么使用指针，不用数组呢？
    uint length;  //当前存储数据的个数
    uint listSize; //顺序表的容量：最多可以存储的元素的个数
}SqList;
```

#### 2.3.1.2 初始化顺序表

逻辑：

* 为存储数据的指针分配空间
* 顺序表长度初始化为0
* 顺序表的容量为 分配的空间/sizeof(ElemType)
  ```
  /*
   * @brief 初始化顺序表
   * @param listSize 顺序表容量
   * @return 返回初始化好的顺序表
   * */
  SqList SqList_init(uint listSize)
  {
      //为线性表存储数据分配空间
      SqList t;
      t.elem = (ElemType *)malloc(listSize*sizeof(ElemType));
      t.length = 0;
      t.listSize = listSize;

      return t;
  }
  ```

#### 2.3.1.3 顺序表的输出

逻辑：

* 根据顺序表的长度遍历整个顺序表
* 将遍历到的每一个数据元素输出

  ```
  /*
   * @brief 打印顺序表中的所有的元素
   * @param t 需要输出的顺序表
   * @return void
   * */
  void print_SqList(SqList t)
  {
      printf("SqList print: ");
      int i;
      for (i = 0; i < t.length; i++)
          printf("%d ", t.elem[i]);
      printf("\n");
  }
  ```

#### 2.3.1.4 顺序表的取值

逻辑：

* 判断需要获取的元素下标是否合法
* 如果不合法则返回一个出错编号
* 如果合法直接返回下标所对应的元素

```
/*
 * @brief 获取顺序表中某个位置的元素
 * @param t 需要操作的顺序表
 * @param index 需要获取的元素的位置/下标
 * @return ElemType 获取到的元素
 * */
ElemType get_elem(SqList t, uint index)
{
    if (index >= t.length)
    {
        printf("index out of range\n");
        return -1;
    }

    return t.elem[index];
}
```

#### 2.3.1.5 顺序表元素的查找

逻辑：

* 通过顺序表的长度遍历整个顺序表
* 将遍历到的元素与需要查找的元素比较，如果不相等则继续往后遍历
* 如果相等则停止遍历，退出循环
* 返回遍历到的元素的下标

```
/*
 * @brief 在顺序表中查找指定的元素
 * @param t 需要操作的顺序表
 * @param elem 需要查找的元素
 * @return int 成功返回值元素的下标，失败返回-1
 * */
int find_elem(SqList t, ElemType elem)
{
    int index = -1; //保存元素的下标，默认需要查找的元素不在顺序表中
    //遍历整个顺序表
    int i;
    for (i = 0; i < t.length; i++)
    {
        if (t.elem[i] == elem)
        {
            index = i;
            break;
        }
    }
  
    if (-1 == index)
        printf("Can not find element : %d\n", elem);
  
    return index;
}
```

#### 2.3.1.6 顺序表的销毁

逻辑：

* 释放初始化顺序表时在堆上分配的空间
* 将顺序表的长度设置为0
* 将顺序表的容量设置为0

```
/*
 * @brief 销毁一个顺序表
 * @param t 需要销毁的顺序表指针
 * */
int SqList_destroy(SqList *t)
{
	if (NULL == t)
		return error;
    if (t->elem != NULL)
    {
        free(t->elem);
        t->length = 0;
        t->listSize = 0;
    }
	return success;
}
```

#### 2.3.1.7 删除指定位置的元素

逻辑：

* 判断需要删除的元素下标是否合法，如果不合法返回出错码
* 将第i+1至length-1（最后一个元素的下标）位的元素往前移动一个位置
* 顺序表长度 -1

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/ab2a3f0c25854518b4b6593aabf33127.png)

```
/*
 * @brief 删除指定位置的元素
 * @param t 需要操作的顺序表指针
 * @param index 需要删除的元素的下标
 * */
int locate_elem_delete(SqList *t, uint index)
{
    if (NULL == t)
        return error;
  
    if (index >= t->length)
    {
        printf("index out of range ...\n");
        return error;
    }


    int i;
    //删除第index个结点，后面的数据移动 t->length - (index + 1)次
    //将第index+1开始到第t.length-1位置的元素往前移动
    for (i = 0; i < t->length - (index + 1); i++)
    {
        t->elem[index+i] = t->elem[index+i+1];
    }

    t->length--;
    return success;
}
```

#### 2.3.1.8 删除指定的元素

逻辑：

* 遍历整个顺序表
* 判断遍历到得元素是否为需要删除得元素，如果不是则继续往后遍历
* 如果相等则将该元素后面得所有元素往前移动一个位置

```
/*
 * @brief 将顺序表中指定的元素删除
 * @param t 需要操作的顺序表指针
 * @param elem 需要删除的元素
 * @return 成功返回OK，失败返回ERROR
 * */
int delete_designated_elem(SqList *t, ElemType elem)
{
    if (NULL == t)
    {
        printf("[%s %d] SqList is NULL\n", __FUNCTION__ , __LINE__);
        return ERROR;
    }

    /*因为顺序表中可能存在多个相同的元素，所以必须要把整个顺序表遍历一遍
    该如何遍历呢？按照次数遍历还是按照其他的规则进行遍历呢？
     因为在删除的过程中顺序表的长度是在变化的，所以不能按照次数进行遍历，我们可以使用一个下标进行移动，当下标移动到最后一个元素时停止遍历
    */
    int i = 0;
    while (i != t->length)
    {
        //先找到需要删除的元素
        if (t->elem[i] != elem)
        {
            i++;
            continue;
        }

        //记录其位置
        int p = i;
        int j;
        //将后面的元素往前移动一个位置
        for (j = 0; j < t->length - (p + 1); j++)
        {
            //将 第 index + i + 1 个元素 覆盖掉 第 index + i个元素
            t->elem[p + j] = t->elem[p + j + 1];
        }
        t->length--;
    }

    return OK;
}
```

#### 2.3.1.9 顺序表的扩容

逻辑：

* 将顺序表的容量扩大到原来的两倍

```
/*
 * @brief 为顺序表扩容
 * @param t 需要扩容的顺序表指针
 * @return 成功返回OK，失败返回ERROR
 * */
int SqList_expand(SqList *t)
{
    if (NULL == t)
    {
        printf("[%s %d] SqList is NULL\n", __FUNCTION__ , __LINE__);
        return ERROR;
    }

    //为顺序表分配新的空间
    t->listSize *= 2;
    //注意：如果分配新的地址空间的首地址与原来分配的空间的首地址相等，不会自动释放原来的空间，如果不相等则会自动释放原来的 空间。
    t->elem = (ElemType *)realloc(t->elem, t->listSize*sizeof(ElemType));

    return OK;
}
```

#### 2.3.1.10 在指定位置前插入元素

逻辑：

* 判断插入的位置是否合法
* 判断顺序表是否满了，如果满了则扩容
* 根据插入的位置计算需要移动的元素个数/次数
* 将指定位置开始的所有元素整体往后移动一个位置（从最后一个位置开始往后移动）
* 将需要插入的元素放置到插入的位置
* 顺序表长度+1

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/9be1536ec4cf4f389425c33557f13725.png)

```
/*
 * @brief 在指定位置的前面插入一个元素
 * @param t 需要操作的顺序表指针
 * @param index 需要插入的位置
 * @param elem 需要插入的元素
 * @return 成功返回OK，失败返回ERROR
 * */
int elem_insert(SqList *t, uint index, ElemType elem)
{
    if (NULL == t)
    {
        printf("[%s %d] SqList is NULL\n", __FUNCTION__ , __LINE__);
        return ERROR;
    }
    //判断插入的位置是否合法
    if (index > t->length)
        return ERROR;

    //判断顺序表是否满了，如果满了则扩容
    if (t->length == t->listSize)
    {
        SqList_expand(t);
        print_SqList(*t);
    }

    int i;
    for (i = 0; i < t->length - index; i++)
    {
        //从最后一个元素开始移动    t->elem[t->length+i] =  t->elem[t->length-1+i]
        t->elem[t->length+i] =  t->elem[t->length-1+i];
    }

    //将需要插入的元素放置到插入的位置
    t->elem[index] = elem;
    t->length++;

    return OK;
}
```

#### 2.3.1.11 顺序表的时间复杂度

**1、获取元素的时间复杂度**

因为可以通过下标法直接获取到对应位置的元素，因为不论顺序表的长度是多少多只需要要访问一次就能够获取到元素，因此时间复杂度为**O(1)**

**2、插入元素的时间复杂度**

每一次插入，都需要把对应位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为**O(n)**

**3、删除元素的时间复杂度**

每一次删除，都需要把对应位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为**O(n)**

### 2.3.2 链表

#### 2.3.2.1 链表的基本概念

　　前面我们在学习顺序表时，线性表的顺序存储结构的特点是逻辑关系上相邻的两个数据元素在物理位置上也是相邻的。我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是增删的效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。为了解决这个问题我们可以使用另外一种存储结构实现线性表，链式存储结构。

　　线性表的链式存储结构（也称之为链表）的特点是逻辑关系上相邻的两个数据元素在物理位置上不一定是相邻的，换言之数据元素在存储器中的位置可以是任意的。为了表示每个数据元素ai与其直接后继 ai+1之间的逻辑关系，对于数据元素ai来说，除了存储其本身的信息外，还需存储一个能够保存直接后继的存储位置的指针，这两部分信息组成数据元素ai的存储映像，我们称之为结点（node）。

　　结点包含两个或者三个域：存储数据元素信息的域叫做**数据域**，存储直接后继存储位置的域叫做**指针域**，存储直接前驱存储位置的域也叫做**指针域**。

　　如果只有一个指针域保存直接后继存储位置，这样的链表我们称之为**单向链表。**![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/f6ae9de63ef84e3184b2b5bf4536de7a.png)

　　如果既有指针域名保存直接后继存储位置，又有指针域存储直接前驱存储位置，这样的链表我们称之为**双向链表**。

　　![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/127b5602115b4694bdf98facd79ee520.png)

　　为了方便对链表进行插入结点和删除结点的操作，一般地链表中的第一个结点不存储实际的数据元素，该结点我们称之为：**头结点**。

　　单向链表的头结点中数据域不存储实际数据元素：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/0abfc1e42d994ac9847fc7973065e4da.png)

　　双向链表的头结点中数据域不存储实际数据元素，并且直接前驱指针域为空（因为头结点没有直接前驱结点）：![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/ce5cad14502b4beea44820d56858437e.png)

#### 2.3.2.2 单向链表

　　在对单向链表进行访问时，需要使用一个指针指向链表中的第一个结点（头结点），这个指针我们称之为：头指针。头指针保存了链表中头结点的存储位置。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/aef0181e8d88424f84fa27747ae4457a.png)

**1、单向链表结点**

```
typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *
```

**2、单向链表初始化**

当链表为空时，头结点的指针域为空：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/cf357417a74942f5862c96d9c0661f77.png)

初始化一个链表：

* 创建一个头结点，头结点的指针域为空
* 创建一个头指针，头指针指向头结点（将头结点的地址赋值给头指针）

```
LinkList list_init()
{
	LNode *t;
	t = (LNode *)malloc(sizeof(LNode)); //创建一个头结点
	t->next = NULL; //头结点的指针域为空

	LinkList head;  //定义一个头指针
	head = t; //头指针指向头结点
    return head;
}
```

**3、单向链表头插法**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/90eda6129bef4ce3bd93a98a08462d22.png)

逻辑：

* 创建一个新的结点p
* 将新的结点p的next指向头节点的下一个结点（head->next）
* 头节点的next指向新的结点p

```
/*
 * @brief 头插法插入一个结点
 * @param 需要插入的链表的头指针
 * @param 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head, ElemType data)
{
    if (NULL == head)
        return FALSE;

    //创建一个新的结点p
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    //将新的结点p的next指向头节点的下一个结点（head->next）
    p->next = head->next;
    //头节点的next指向新的结点p
    head->next = p;

    return TRUE;
}
```

**4、单向链表的打印**

逻辑：

* 使用一个临时指针指向头节点后的第一个结点
* 使用临时指针进行遍历，知道临时指针为NULL

```
/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head->next;
    while (t != NULL)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    return TRUE;
}
```

**5、单向链表尾插法**

逻辑：

* 新建一个新的结点
* 将尾指针的next指向新的结点
* 将尾指针指向新的结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/6d35acd47761478a8249d70a4ca03ee8.png)

改造head_insert函数，将链表的尾结点指针的地址传入：

```
/*
 * @brief 头插法插入一个结点
 * @param head 需要插入的链表的头指针
 * @param tail 尾结点指针的地址
 * @param data 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head,LNode **tail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点p
    LNode *p;
    p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    p->next = NULL;

    //如果链表为空，那么第个插入的结点就是整个链表的尾结点
    if (NULL == head->next)
        *tail = p;

    //将新的结点p的next指向头节点的下一个结点（head->next）
    p->next = head->next;

    //头节点的next指向新的结点p
    head->next = p;
  
    return TRUE;
}
```

尾插法示例代码：

```
/*
 * @brief 尾插法插入一个结点
 * @param head 需要插入的链表的头指针
 * @param tail 尾结点指针的地址
 * @param data 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int tail_insert(LinkList head,LNode **tail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点p
    LNode *p;
    p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    p->next = NULL;

    //如果链表为空，将头节点的next指向新的结点
    if (NULL == head->next)
    {
        head->next = p;
    }
    else
    {
        (*tail)->next = p;
    }
    *tail = p;
    return TRUE;
}
```

**6、获取链表上指定的元素**

逻辑：

* 从链表的第一个数据结点开始遍历
* 将遍历到的每一个结点上的数据域与需要获取/查找的元素比较
* 如果相等返回该结点的地址
* 如果不相等则继续往后遍历
* 如果遍历到链表末尾依然没有找到则返回NULL

```
/*
 * @brief 获取链表上指定的元素
 * @param head 需要查找的链表的头指针
 * @param data 需要查找的元素
 * @return 成功返回元素所在结点的地址，失败返回NULL
 * */
LNode *get_elem(LinkList head, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return NULL;
    }

    LNode *t;
    t = head->next;
    while (t != NULL)
    {
        if (t->data == data)
            return t;
        t = t->next;
    }

    return NULL;
}
```

**7、获取链表上指定位置的元素**

逻辑：

* 从链表的第一个数据结点开始遍历
* 每遍历一个结点遍历次数+1，同时判断是否遍历到了链表的末尾
* 如果遍历到了链表末尾返回NULL
* 或者遍历到了指定位置返回结点指针

```
/*
 * @brief 获取指定位置的元素
 * @param 需要遍历的链表的头指针
 * @param index 需要遍历到的位置（从1开始）
 * @return 成功返回对应位置的结点指针，失败返回NULL
 * */
LNode *get_elem_by_index(LinkList head, uint index)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n",__FUNCTION__ , __LINE__);
        return NULL;
    }

    //用一个临时指针指向链表的第一个数据结点
    LNode *t = head->next;
    int i=1;
    //判断是否遍历到了链表末尾或者遍历到了指定的位置
    while (i<=index && t!=NULL)
    {
        i++;
        t = t->next;
    }

    return t;
}
```

**8、删除链表上指定位置的元素**

逻辑：

* 使用临时指针 t 从链表的第一个数据结点开始遍历
* 使用临时指针 p 保存遍历到的结点的前驱结点
* 每遍历一个结点遍历次数+1，指针 p 与随之往后移动，同时判断是否遍历到了链表的末尾
* 如果遍历到了链表的末尾则返回FALSE
* 如果遍历到的位置恰好是最后一个结点（尾结点），则将尾指针指向该结点的前一个结点，尾指针的next赋值为NULL，并且删除最后一个结点
* 如果遍历到的结点是中间结点，则将前驱结点指向遍历到的结点的下一个结点（指针 p->next = t->next）

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/0d535f10be3b49fcb1b7f1efc6f24533.png)

```
/*
 * @brief 删除指定位置的结点
 * @param head 需要删除的链表的头指针
 * @param tail 需要删除的链表的尾指针地址
 * @param index 需要删除的元素的位置
 * @return 成功返回TRUE，失败返回FALSE
 * */
int delete_by_index(LinkList head, LNode **tail, uint index)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n",__FUNCTION__ , __LINE__);
        return FALSE;
    }

    LNode *t = head->next;
    LNode *p = head;
    int i = 1;
    while (i < index && t != NULL)
    {
        i++;
        t = t->next;
        p = p->next;
    }
    if (t == NULL)
    {
        printf("[%s %d]  can not delete\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //如果刚好是遍历到了最后一个结点
    if (t->next == NULL)
    {
        *tail = p;
        (*tail)->next = NULL;
        free(t);
        return TRUE;
    }

    //如果是中间的结点
    p->next = t->next;
    free(t);
    return TRUE;
}
```

**9、删除链表上指定元素所在的结点**

逻辑：

* 使用临时指针t从链表的第一个数据结点开始遍历，一直遍历到链表末尾
* 使用临时指针 p 保存遍历到的结点的前驱结点
* 将遍历到的每一个结点上的数据域与需要删除的元素比较
* 如果遍历到的结点恰好是尾结点，将尾指针tail指向需要删除的结点的前驱结点p，尾指针tail->next=NULL，释放当前结点free(t)，返回TRUE
* 如果遍历到的结点是中间结点，驱结点指向当前结点的下一个结点p->next = t->next， 释放当前结点free(t)，临时指针t指向下一个结点继续往后遍历 t = p->next

```
/*
 * @brief 删除指定元素所在的结点
 * @param head 需要删除的链表的头指针
 * @param tail 需要删除的链表的尾指针地址
 * @param data 需要删除的元素的值
 * @return 成功返回TRUE，失败返回FALSE
 * */
int delete_by_elem_value(LinkList head, LNode **tail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    LNode *t = head->next;
    LNode *p = head;
    //遍历到链表的末尾
    while (t != NULL) //while (t)
    {
        //如果遍历到了需要删除的结点
        if (t->data == data)
        {
            //如果当前结点为尾结点
            if (t->next == NULL)
            {
                *tail = p;
                (*tail)->next = NULL;
                free(t);
                return TRUE;
            }

            //如果是中间的结点  前驱结点指向当前结点的下一个结点
            p->next = t->next;
            free(t);
            t = p->next;
        }
        else
        {
            t = t->next;
            p = p->next;
        }
    }
    return TRUE;
}
```

**10、在链表指定位置/指定位置前插入一个结点**

逻辑：

* 使用临时指针 t 从链表的第一个数据结点开始遍历
* 使用临时指针 p 保存遍历到的结点的前驱结点
* 每遍历一个结点遍历次数+1，指针 p 与随之往后移动，同时判断是否遍历到了链表的末尾
* 如果遍历到了链表的末尾则返回FALSE
* 如果遍历到了指定的位置
* 创建一个新的结点n
* 将前驱结点p指向新的结点n，p->next = n，将新的结点指向遍历到的结点， n->next = t
* 返回TRUE

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/9ea474c641cf4f619a8303a579c77a61.png)

```
/*
 * @brief 在指定位置插入一个元素
 * @param head 需要插入的链表的头指针
 * @param index 需要插入的元素的位置
 * @param data 需要插入的元素的值
 * @return 成功返回TRUE，失败返回FALSE
 * */
int insert_by_index(LinkList head,  uint index, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    LNode *t = head->next;
    LNode *p = head;
    int i = 1;
    while (i < index && t != NULL)
    {
        i++;
        t = t->next;
        p = p->next;
    }

    //如果将整个链表遍历完毕了，则说明需要插入的位置不在链表上（超出了链表的长度）
    if (NULL == t)
    {
        printf("[%s %d]  index: %d out of range ...\n", __FUNCTION__ , __LINE__, index);
        return FALSE;
    }

    //创建一个新的结点p
    LNode *n;
    n = (LNode *)malloc(sizeof(LNode));
    n->data = data;
    n->next = NULL;

    //如果是中间结点将前驱结点p指向新的结点n，p->next = n，将新的结点指向遍历到的结点， n->next = t
    p->next = n;
    n->next = t;
    return TRUE;
}
```

**11、插入一个元素使得整个链表依然保持为升序（原链表为升序）**

逻辑：找到一个比需要插入的元素大的结点，在这个结点的前面插入新的结点

* 使用临时指针 p 保存遍历到的结点的前驱结点
* 使用临时指针 t 从链表的第一个数据结点开始遍历
* 每遍历一个结点遍历次数+1，指针 p 与随之往后移动，同时判断遍历到的结点是否比需要插入的元素大
* 如果比需要插入的元素小则继续往后遍历
* 如果比需要插入的元素大，新创建一个结点n
* 判断该结点是否为尾结点，如果是尾结点 t->next = n, tail = n
* 如果不是尾结点将前驱结点p指向新的结点n，p->next = n，将新的结点指向遍历到的结点， n->next = t
* 如果将整个链表遍历完毕依然没有找到比需要插入的元素大的结点，则说明该结点将会是整个链表上最大的结点，应该插入到链表的末尾。 p->next = n, tail = n ,或者调用尾插法函数

```
/*
 * @brief 插入一个元素使得整个链表依然保持为升序（原链表为升序）
 * @param head 链表的头指针
 * @param pTail 链表的尾指针地址
 * @param data 需要插入的元素的值
 * @return 成功返回TRUE，失败返回FALSE
 * */
int ascending_insert(LinkList head, LNode **pTail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点p
    LNode *n;
    n = (LNode *)malloc(sizeof(LNode));
    n->data = data;
    n->next = NULL;

    LNode *t = head->next;
    LNode *p = head;
    while (t  != NULL)
    {
        if (t->data <= data)
        {
            t = t->next;
            p = p->next;
            continue;
        }

        //前驱结点p指向新的结点n，p->next = n，将新的结点指向遍历到的结点， n->next = t
        p->next = n;
        n->next = t;
        break;
    }

    //如果将整个链表遍历完毕依然没有找到比需要插入的元素大的结点，则说明该结点将会是整个链表上最大的结点，应该插入到链表的末尾
    // p->next = n, tail = n ,或者调用尾插法函数
    p->next = n;
    *pTail = n;

    return TRUE;
}
```

**12、销毁链表**

逻辑：

* 使用临时指针 t 从链表的第一个数据结点开始遍历，直到遍历到链表的末尾
* 每遍历到一个结点首先将头结点的next赋值为当前节点的下一个结点  head->next = t->next， 然后临时指针t指向下一个结点  t = head->next
* 如果整个链表遍历完毕则删除结点

```c
/*
 * @brief 销毁链表
 * @param head 需要销毁的链表的头指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int list_destroy(LinkList head)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    LNode *t = head->next;

    while (t != NULL)
    {
        head->next = t->next;
        free(t);
        t = head->next;
    }
    //把头结点也释放掉
    free(head);
    return TRUE;
}
```

#### 2.3.2.3 单向链表高频笔试题

**1、单向链表的原地反转**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/9c321baaf14e4b6a8907105e77108178.png)

逻辑：

* 使用两个指针prev 和 pCur，pCur是需要反转的结点，prev为需要反转的结点的前驱结点
* 让prev的指针域指向需要反转结点的下一个结点：prev->next = pCur->next
* 将pCur反转到prev前：pCur->next = head->next
* 将头指针的next指向反转后的结点：head->next = pCur
* pCur指向下次需要反转的结点：pCur = prev->next

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/f9750b5488044bc089c8c783d649f252.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/17e075495c034f6e9ebeb8ae6a3519ef.png)

算法实现：单向链表的反转.c

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *

LinkList list_init()
{
	LNode *t;
	t = (LNode *)malloc(sizeof(LNode)); //创建一个头结点
	t->next = NULL; //头结点的指针域为空

	LinkList head;  //定义一个头指针
	head = t; //头指针指向头结点
    return head;
}

/*
 * @brief 头插法插入一个结点
 * @param 需要插入的链表的头指针
 * @param 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head, ElemType data)
{
    if (NULL == head)
        return FALSE;

    //创建一个新的结点p
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    //将新的结点p的next指向头节点的下一个结点（head->next）
    p->next = head->next;
    //头节点的next指向新的结点p
    head->next = p;

    return TRUE;
}

/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head->next;
    while (t != NULL)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
    return TRUE;
}

LinkList reverse(LinkList head)
{
    if (NULL == head || NULL == head->next)
        return head;

    LNode *prev, *pCur;
    //prev 指向第一个数据结点
    prev = head->next;
    //pCur指向第二个数据结点
    pCur = prev->next;
    if (NULL == pCur) //如果只有一个数据结点，不需要反转
        return head;

    while (pCur != NULL)
    {
        prev->next = pCur->next;
        pCur->next = head->next;
        head->next = pCur;
        pCur = prev->next;
    }

    return head;
}

int main()
{
    LinkList head;
    head = list_init();

    int i;
    for (i = 0; i < 5; i++)
        head_insert(head, 100+i);

    print_list(head);

    head = reverse(head);
    print_list(head);

    return 0;
}
```

**2、查找链表的中间结点**

**要求：只能遍历一次链表**

**思路：快慢指针**

* 定义两个指针slow、fast
* slow每次遍历一个结点
* fast每次遍历两个结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/3fc0c49f884e4588bea0e8c4192f5c81.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/a743747406874728b2a5e8f686b0497a.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/6f329924193843c98aad2ff891b937d7.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/b109fdf92d544ce6907cc595941b624f.png)

算法实现：get_mid.c

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *

LinkList list_init()
{
	LNode *t;
	t = (LNode *)malloc(sizeof(LNode)); //创建一个头结点
	t->next = NULL; //头结点的指针域为空

	LinkList head;  //定义一个头指针
	head = t; //头指针指向头结点
    return head;
}

/*
 * @brief 头插法插入一个结点
 * @param 需要插入的链表的头指针
 * @param 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head, ElemType data)
{
    if (NULL == head)
        return FALSE;

    //创建一个新的结点p
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    //将新的结点p的next指向头节点的下一个结点（head->next）
    p->next = head->next;
    //头节点的next指向新的结点p
    head->next = p;

    return TRUE;
}

/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head->next;
    while (t != NULL)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
    return TRUE;
}

LNode *get_mid(LinkList head)
{
    LNode *slow, *fast;
    slow = head->next;
    fast = head->next;
    while (fast != NULL && fast->next != NULL)
    {
        fast = fast->next->next;
        slow = slow->next;
    }

    return slow;
}

int main()
{
    LinkList head;
    head = list_init();

    int i;
    for (i = 0; i < 6; i++)
        head_insert(head, 100+i);

    print_list(head);

    LNode *item;
    item = get_mid(head);
    printf("%d\n", item->data);

    return 0;
}
```

**3、判断链表是否有环**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/6e0ca8132edf43f29f2f06b18b6e6fad.png)

思路：

* 使用快慢指针
* 如果存在环，最终在某个时间点快慢指针会相遇

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/0b070da9d56142c8aa147141af17f6bc.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/987960e739694b329244e8acad0160db.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/e86c818c9672498e9dfbde53eee49a89.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/22c6130bf40c45ab87431d214697dfae.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/2b9bc7ece0eb46f3b88179f98fa9da1d.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/df2bdb1b577f492a849b8be2f40c61af.png)

算法实现：find_loop.c

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *

LinkList list_init()
{
	LNode *t;
	t = (LNode *)malloc(sizeof(LNode)); //创建一个头结点
	t->next = NULL; //头结点的指针域为空

	LinkList head;  //定义一个头指针
	head = t; //头指针指向头结点
    return head;
}

/*
 * @brief 头插法插入一个结点
 * @param 需要插入的链表的头指针
 * @param 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head, ElemType data)
{
    if (NULL == head)
        return FALSE;

    //创建一个新的结点p
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    //将新的结点p的next指向头节点的下一个结点（head->next）
    p->next = head->next;
    //头节点的next指向新的结点p
    head->next = p;

    return TRUE;
}

/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head->next;
    while (t != NULL)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
    return TRUE;
}

LNode *find_loop(LinkList head)
{
    LNode *fast, *slow ; 
    slow = fast = head->next ; 
   
    while (slow != NULL && fast fast -> next != NULL) 
    { 
        slow = slow -> next ; 
        fast = fast -> next -> next ; 
        if (slow == fast) 
            return slow;
    } 

    return NULL;
}

int main()
{
    LinkList head;
    head = list_init();

    int i;
    for (i = 0; i < 6; i++)
        head_insert(head, 100+i);
    print_list(head);

    //人为在链表上添加一个环
    //使用一个指针记住链表上的第三个结点
    LNode *flag = head->next->next->next;

    //找到最后一个结点
    LNode *tail = head->next;
    while (tail->next != NULL)
        tail = tail->next;

    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = 200;

    tail->next = p;
    p->next = flag;

    LNode *loop = find_loop(head);
    if (loop != NULL)
        printf("%d\n", loop->data);
    else
        printf("no loop\n");

    return 0;
}
```

**4、查找带环链表中环的入口**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/e9006b154aa94cb3a743c2401f5f91c3.png)

通过判断一个单向链表是否有环我们知道，如果有环的存在，假设环的长度为r，那么当快指针fast和慢指针slow相遇的时候，假如fast指针已经在环上走了n圈，假如slow走了s步，那么fast就走了2s步，又因为fast走过的步数 = s + n*r，则有下面的等式：

2*s = s + n  * r ;   (1)

=> s = n*r；    (2)

如果假设整个链表的长度是L，入口和相遇点的距离是x（如上图所示），起点到入口点的距离是a(如上图所示)，则有：

a + x = s = n * r;   (3)    由（2）推出

a + x = (n - 1) * r + r  = (n - 1) * r + (L - a)   (4)  由环的长度 = 链表总长度 - 起点到入口点的距离求出

a = (n - 1) * r + (L -a -x)   (5)

集合式子（5）以及上图我们可以看出，从链表起点开始到入口点的距离a,与从slow和fast的相遇点（如图）到入口点的距离相等。

因此我们就可以分别用一个指针（ptr1, prt2），同时从head与slow和fast的相遇点出发，每一次操作走一步，直到ptr1 == ptr2，此时的位置也就是入口点！

算法实现：find_entrance.c

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *

LinkList list_init()
{
	LNode *t;
	t = (LNode *)malloc(sizeof(LNode)); //创建一个头结点
	t->next = NULL; //头结点的指针域为空

	LinkList head;  //定义一个头指针
	head = t; //头指针指向头结点
    return head;
}

/*
 * @brief 头插法插入一个结点
 * @param 需要插入的链表的头指针
 * @param 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head, ElemType data)
{
    if (NULL == head)
        return FALSE;

    //创建一个新的结点p
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    //将新的结点p的next指向头节点的下一个结点（head->next）
    p->next = head->next;
    //头节点的next指向新的结点p
    head->next = p;

    return TRUE;
}

/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head->next;
    while (t != NULL)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
    return TRUE;
}

LNode *find_entrance(LinkList head)
{
    LNode *fast, *slow ; 
    slow = fast = head->next ; 
   
    while (slow != NULL && fast -> next != NULL) 
    { 
        slow = slow -> next ; 
        fast = fast -> next -> next ; 
        if (slow == fast) 
            break;
    } 
    if (slow == NULL || fast -> next == NULL) 
        return NULL ; //没有环，返回NULL值 

    LNode * ptr1 = head->next ; //链表开始点 
    LNode * ptr2 = slow ; //相遇点 
    while (ptr1 != ptr2)  
    { 
        ptr1 = ptr1 -> next ; 
        ptr2 = ptr2 -> next ; 
    } 
    return ptr1 ; //找到入口点 
}

int main()
{
    LinkList head;
    head = list_init();

    int i;
    for (i = 0; i < 6; i++)
        head_insert(head, 100+i);
    print_list(head);

    //人为在链表上添加一个环
    //使用一个指针记住链表上的第三个结点
    LNode *flag = head->next->next->next;

    //找到最后一个结点
    LNode *tail = head->next;
    while (tail->next != NULL)
        tail = tail->next;

    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = 200;

    tail->next = p;
    p->next = flag;

    LNode *loop = find_entrance(head);
    if (loop != NULL)
        printf("%d\n", loop->data);
    else
        printf("no loop\n");

    return 0;
}
```

#### 2.3.2.4 单向循环链表

**1、单向循环链表的概念**

循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为NULL，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/e02ec47e6d034dfcb5d8060c1750adce.png)

**2、单向循环链表的创建**

singleListLoop.c

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *

LinkList list_init()
{
	LNode *t;
	t = (LNode *)malloc(sizeof(LNode)); //创建一个头结点
	t->next = NULL; //头结点的指针域为空

	LinkList head;  //定义一个头指针
	head = t; //头指针指向头结点
    return head;
}

/*
 * @brief 头插法插入一个结点
 * @param 需要插入的链表的头指针
 * @param 需要插入的数据
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int head_insert(LinkList head, ElemType data)
{
    if (NULL == head)
        return FALSE;

    //创建一个新的结点p
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;

    if (NULL == head->next)
        p->next = head;
    else
        //将新的结点p的next指向头节点的下一个结点（head->next）
        p->next = head->next;
    //头节点的next指向新的结点p
    head->next = p;

    return TRUE;
}

/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head->next;
    while (t != head)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
    return TRUE;
}

int main()
{
    LinkList head;
    head = list_init();

    int i;
    for (i = 0; i < 6; i++)
        head_insert(head, 100+i);
    print_list(head);

    return 0;
}
```

**3、约瑟夫环**

**问题描述：**

传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。

**问题转换：**

41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。

1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；

2.自退出那个人开始的下一个人再次从1开始报数，以此类推；

3.求出最后退出的那个人的编号。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/5126484882d74a41ab8695cbb7b2e34d.png)

**解题思路：**

* 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；
* 使用计数器count，记录当前报数的值；
* 遍历链表，每循环一次，count++；
* 判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；

算法实现：JosephRing.c

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;

typedef struct LNode{
	ElemType data;  //数据域
	struct LNode *next; //指针域，指向当前结点的直接后继（下一个结点）
}LNode, *LinkList; //LinkList的类型为 LNode *

/*
 * @brief 输出链表中的所有结点
 * @param head 链表的头指针
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_list(LinkList head)
{
    if (NULL == head)
        return FALSE;

    //使用一个临时指针对链表进行遍历
    LNode *t;
    t = head;
    int i = 0;
    for (i = 0; i < 41; i++)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
    return TRUE;
}

void JosephRing(int num)
{
    //使用不带头结点的方式创建一个约瑟夫环
    int i;
    LNode *head; //第一个结点/头指针
    head = (LNode *)malloc(sizeof(LNode));
    LNode *tail = head;
    for (i = 1; i < 41; i++)
    {
        tail->data = i;
        tail->next = (LNode *)malloc(sizeof(LNode));
        tail = tail->next;
    }
    tail->data = i;
    tail->next = head;
    print_list(head);

    LNode *t = head;
    LNode *pre = NULL;

    int cnt = 0;
    while (t != t->next)
    {
        cnt++;
        if (cnt == num)   
        {
            printf("%d: out\n", t->data);
            pre->next = t->next;
            free(t);
            t = pre->next;
            cnt = 0;
        }
        else 
        {
            pre = t;
            t = t->next;
        }
    }
    printf("%d :left\n", t->data);
}

int main()
{
    JosephRing(3);

    return 0;
}
```

#### 2.3.2.5 带信息结点的单向链表

#### 2.3.2.6 双向链表

**1、双向链表的概念**

　　双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/439b9e68c5ad4ad680189e49ab97bfab.png)

　　与访问单向链表一样对于双向链表的访问也需要使用头指针。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1647868205089/2815497219754d57a618fd8dc4258bfa.png)

**2、双向链表的结点**

```c
typedef struct DuLNode
{
    ElemType data;
    struct DuLNode *pre; //指向前驱结点的指针
    struct DuLNode *next; //指向后继结点的指针
}DuLNode, *DuLinkList;
```

**3、双向链表的初始化**

```c
DuLinkList list_init()
{
    DuLinkList head;
    //创建一个头结点，使用head指针指向头结点（头指针）
    head = (DuLinkList)malloc(sizeof(DuLNode));
    head->next = NULL;
    head->pre = NULL;
    return head;
}
```

**4、双向链表头插法**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/5cd854c122a44526b770abac0a480bac.png)

```c
/*
 * @brief 双向链表头插法
 * @param head 双向链表头指针
 * @param pTail 双向链表尾指针地址
 * @param data 需要插入的元素的值
 * @return 成功返回TRUE 失败返回FALSE
 * */
int head_insert(DuLinkList head, DuLNode **pTail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点
    DuLNode *p = (DuLNode *)malloc(sizeof(DuLNode));
    p->pre = NULL;
    p->next = NULL;
    p->data = data;

    //如果链表为空
    if (NULL == head->next)
    {
        //第一个插入的结点就是尾结点
        *pTail = p;
        head->next = p;
        return TRUE;
    }

    p->next = head->next;
    head->next = p;
    return TRUE;
}

```

**5、双向链表从头结点开始打印**

```c
//从头结点开始打印
void print_list_from_head(DuLinkList head)
{
    if (NULL == head)
        return;

    DuLNode *t = head->next;
    while (t != NULL)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
}
```

**6、双向链表从尾结点开始打印**

```c
//从尾结点开始打印
void print_list_from_tail(DuLNode *tail)
{
    if (NULL == tail)
        return;

    DuLNode *t = tail;
    //一直遍历到头结点
    while (t->pre != NULL)
    {
        printf("%d ", t->data);
        t = t->pre; //向前开始遍历
    }
    printf("\n");
}
```

**7、双向链表尾插法**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/69602f75f7e14297980ee5771effa112.png)

```c
/*
 * @brief 双向链表尾插法
 * @param head 双向链表头指针
 * @param pTail 双向链表尾指针地址
 * @param data 需要插入的元素的值
 * @return 成功返回TRUE 失败返回FALSE
 * */
int tail_insert(DuLinkList head, DuLNode **pTail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head point is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点
    DuLNode *p = (DuLNode *)malloc(sizeof(DuLNode));
    p->pre = NULL;
    p->next = NULL;
    p->data = data;

    //判断链表是否为空
    if (NULL == head->next)
    {
        *pTail = p;
        p->pre = head;
        head->next = p;
        return TRUE;
    }

    (*pTail)->next = p;
    p->pre= *pTail;
    *pTail = p;

    return TRUE;
}
```

**8、双向链表在指定的位置插入结点**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/6a1a446207964ad6b5488eca8f7182bc.png)

```c
/*
 * @brief 在双向链表指定位置插入一个结点
 * @param head 双向链表头指针
 * @param index 需要插入的位置
 * @param data 需要插入的元素的值
 * @return 成功返回TRUE 失败返回FALSE
 * */
int insert_by_index(DuLinkList head, uint index, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head point is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    int i = 1;
    DuLNode *t = head->next;

    while (i < index && t != NULL)
    {
        i++;
        t = t->next;
    }

    if (NULL == t)
    {
        printf("[%s %d] index out of range ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点
    DuLNode *p = (DuLNode *)malloc(sizeof(DuLNode));
    p->pre = NULL;
    p->next = NULL;
    p->data = data;

    p->next = t;
    p->pre = t->pre;
    t->pre->next = p;
    t->pre = p;

    return TRUE;

}
```

**9、双向链表插入一个结点保持原链表为升序**

```c
/*
 * @brief 双向链表插入一个结点保持原链表为升序
 * @param head 双向链表头指针
 * @param pTail 双向链表尾指针地址
 * @param data 需要插入的元素的值
 * @return 成功返回TRUE 失败返回FALSE
 * */
int ascending_insert(DuLinkList head, DuLNode **pTail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head point is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点
    DuLNode *p = (DuLNode *)malloc(sizeof(DuLNode));
    p->pre = NULL;
    p->next = NULL;
    p->data = data;

    DuLNode *t = head->next;
    //判断是否为空
    if (NULL == head->next)
    {
        head->next = p;
        p->pre = head;
        *pTail = p;
        return TRUE;
    }

    while (t != NULL)
    {
        if (t->data <= data)
        {
            //继续往后遍历
            t = t->next;
            continue;
        }

        p->next = t;
        p->pre = t->pre;
        t->pre->next = p;
        t->pre = p;
        return TRUE;
    }
    //如果链表遍历完毕，说明需要插入的结点比链表上的所有结点都要大应该插入到链表的末尾
    (*pTail)->next = p;
    p->pre = *pTail;
    *pTail = p;

    /*
     * 假如没有尾指针，遍历链表的时候，当遍历到链表的最后一个结点的时候就要停止遍历
     * */
    /*
    while (t->next != NULL)
    {
        if (t->data <= data)
        {
            //继续往后遍历
            t = t->next;
            continue;
        }

        p->next = t;
        p->pre = t->pre;
        t->pre->next = p;
        t->pre = p;
        return TRUE;
    }

    if (t->data <= data){
        p->next = t;
        p->pre = t->pre;
        t->pre->next = p;
        t->pre = p;
    }
    else
    {
        t->next = p;
        p->pre = t;
    }
     */
    return TRUE;
}
```

**10、删除双向链表上指定位置的结点**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/fb73cd4feb204a5f924018a19075864c.png)

```c
/*
 * @brief 删除指定位置的元素
 * @param head 双向链表头指针
 * @param pTail 双向链表尾指针地址
 * @param index 需要删除的元素的位置
 * @return 成功返回TRUE 失败返回FALSE
 * */
int delete_by_index(DuLinkList head, DuLNode **pTail, uint index)
{
    if (NULL == head)
    {
        printf("[%s %d] head point is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    if (0 == index)
    {
        printf("[%s %d] index must > 0\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    int i = 1;
    DuLNode *t = head->next;
    while (i < index && t != NULL)
    {
        i++;
        t = t->next;
    }

    //如果链表遍历完了
    if (NULL == t)
    {
        printf("[%s %d] index out of range ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //如果要删除的结点恰好是尾结点
    if (t == *pTail)  //if (t->next == NULL)
    {
        *pTail = t->pre;
        (*pTail)->next = NULL;
        free(t);
        return TRUE;
    }

    //如果是中间结点
    t->pre->next = t->next;
    t->next->pre = t->pre;
    free(t);
    return TRUE;
}

int print_stack(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }

    ElemType *t = s->top;
    t--;
    while (t != s->base)
    {
        printf("%d ", *t);
        t--;
    }
    printf("%d \n", *t);
    return TRUE;
}
```

**11、删除链表上指定的元素**

```c
/*
 * @brief 删除指定位置的元素
 * @param head 双向链表头指针
 * @param pTail 双向链表尾指针地址
 * @param data 需要删除的元素的值
 * @return 成功返回TRUE 失败返回FALSE
 * */
int delete_by_value(DuLinkList head, DuLNode **pTail, ElemType data)
{
    if (NULL == head)
    {
        printf("[%s %d] head point is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    DuLNode *t = head->next;
    //遍历整个链表
    while (t != NULL)
    {
        if (t->data != data)
        {
            t = t->next;
            continue;
        }

        //判断是否需要删除的结点恰好是尾结点
        if (t->next == NULL)
        {
            *pTail = t->pre;
            (*pTail)->next = NULL;
            free(t);
            return TRUE;
        }

        //如果是中间结点
        //先保存t结点的直接后继
        DuLNode *bak = t->next;
        t->pre->next = t->next;
        t->next->pre = t->pre;
        free(t);
        t = bak;
    }

    return TRUE;
}
```

**12、销毁双向链表**

```c
/*
 * @brief 销毁链表
 * @param head 双向链表头指针
 * @param pTail 双向链表尾指针地址
 * @return 成功返回TRUE 失败返回FALSE
 */
int list_destroy(DuLinkList head, DuLNode **pTail)
{
    if (NULL == head)
    {
        printf("[%s %d] head point is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    DuLNode *t = head->next;
    while (t->next != NULL)
    {
        //头结点的next指向t的后继结点
        head->next = t->next;

        //t的后继结点的pre指向头结点
        t->next->pre = head;
        free(t);
        t = head->next;
    }

    //剩下最后一个尾结点
    head->next = NULL;
    free(t);
    free(head);
    *pTail = NULL;

    return TRUE;
}

```

#### 2.3.2.7 带信息结点的双向链表

**1、信息结点**

```c
typedef struct infoNode
{
	DuLNode *head; //指向头结点的指针
	DuLNode *tail; //指向尾结点的指针
	uint len; //链表的长度
	char *desc; //存储链表描述信息
}infoNode, *PinfoNode;
```

**2、链表的初始化**

```c

infoNode *list_init1()
{
    infoNode *L;
    L = (infoNode *)malloc(sizeof(infoNode));

    //创建一个头结点
    L->head = (DuLNode *)malloc(sizeof(DuLNode));
    L->head->next = NULL;
    L->tail = NULL;
    L->len = 0;
    L->desc = (char *)malloc(32);
    strcpy(L->desc, "test list");

    return L;
}
```

#### 2.3.2.8 双向循环链表

双向循环链表最后一个节点的next指向头结点，头结点的pre指向最后一个结点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/9595e98808984e5da85b8ff160c3e0a3.png)

#### 2.3.2.9 链表的时间复杂度

**1、获取元素的时间复杂度**

每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为**O(n)**

**2、插入元素的时间复杂度**

每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为**O(n)**

**3、删除元素的时间复杂度**

每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为**O(n)**

**4、顺序表和链表的比较**

相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,同时它并没有涉及的元素的交换。

相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。

# 三、栈和队列

栈和队列也是一种线性结构。它们也都用于存储逻辑关系为 "一对一" 的数据，但由于它们比较特殊，因此将其单独作为一章，做重点讲解。

## 3.1 栈

### 3.1.1 栈的概述

**1、栈的基本概念**

栈是一种基于**先进后出（FILO）或者后进先出（LIFO）**的数据结构，是一种**只能在一端进行插入和删除**操作的特殊线性表。它按照先进后出的原则存储数据，**先进入的数据被压入栈底**，**最后的数据在栈顶**，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

我们称数据进入到栈的动作为**压栈（入栈）**，数据从栈中出去的动作为**弹栈（出栈）**。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d6667a8b9eb74533a71669aab4bb75f7.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d4bfac7fcfc844ec864c827e67443243.png)

**2、栈的应用**

* 举例1：我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，我们可以使用浏览器的"回退"功能。浏览器会先回退到页面 B，而后再回退到页面 A。浏览器 "回退" 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。
* 举例2：表达式求值
  * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/cf78aa724ee948c8a327b1def8e52b70.png)
* 举例3：数制的转换，比如给定十进制数N=1348,转换为八进制数R=2504
  * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/a31a6dc6e9b74e0dbda117e3d2ea2a3f.png)
* 举例4：二叉树的遍历，后面的课程详细讲解

**3、笔试题**

例题：一个栈的初始状态为空。将元素abcde依次入栈，不可能的出栈顺序（）

A.edcba

B.dcbae

C.badce

D.cbaed

E.eabcd

**答案：E**

**解析：abcde的进栈顺序并不是一次性的按照abcde入栈，也可能是先入栈一部分再出栈一部分在进行入栈**

**4、栈的具体实现**

* **顺序栈**：使用数组实现
* **链式栈**：使用链表实现

### 3.1.2 顺序栈

在实现顺序栈之前，我们先来看一看对于顺序栈的操作：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/26fb56a1f57d4f6180f63e4126c7adcb.png)

顺序栈可以使用一维数组实现，base指针指向栈底（数组的第0个元素），top指针是动态的，每次都指向栈顶元素（最后一个放入栈中的元素），因此，我们将base指针称之为：栈底指针，将top指针称之为**栈顶指针**。

**1、顺序栈的描述结构体**

```c
#define STACK_INIT_LEN 100
#define STACKINCREMENT 10

typedef struct SqStack{
    ElemType *top; //栈顶指针
    ElemType *base;
    uint stackLen;
}SqStack;
```

**2、顺序栈的初始化**

```c
/*
 * @brief 初始化一个顺序栈
 * @param 初始顺序栈的长度
 * @return 返回初始化后的栈的指针
 * */
SqStack *stack_init(uint size)
{
    //创建一个栈
    SqStack *s = (SqStack *)malloc(sizeof(SqStack));

    //为栈分配空间
    s->base = (ElemType *)malloc(size*sizeof(ElemType));
    s->top = s->base;
    s->stackLen = size;
    s->len = 0;
    return s;
}
```

**3、对顺序栈进行扩容**

```c
/*
 * @brief 对栈进行扩容
 * @param s 需要扩容的栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 */
int expand(SqStack *s)
{
    printf("[%s %d] stack expand ...\n", __FUNCTION__ , __LINE__);
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //为栈重新分配空间，栈底指针指向新的分配好的空间
    s->base = (ElemType *)realloc(s->base, (s->stackLen+STACKINCREMENT)*sizeof(ElemType));
    //栈顶指针指向新的栈顶元素
    s->top = s->base + s->stackLen;
    s->stackLen += STACKINCREMENT;

    return TRUE;
}
```

**4、入栈**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/1030b318028d44e99d8015951bdcf7b7.png)

```c
/*
 * @brief 入栈
 * @param s 栈指针
 * @param data 需要入栈的元素
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int push(SqStack *s, ElemType data)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }
    //如果栈满了
    if (s->top - s->base >= s->stackLen)
        expand(s);
    *(s->top) = data;
    s->top++;

    return TRUE;
}

```

**5、出栈**

```c
/*
 * @brief 出栈
 * @param s 栈指针
 * @param data 存放栈顶元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int pop(SqStack *s, ElemType *data)
{
    if (NULL == s || NULL == data)
        return FALSE;
    //如果栈为空
    if (s->top == s->base)
    {
        printf("[%s %d] stack is empty ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }
    s->top--;
    *data = *(s->top);

    return TRUE;
}
```

**6、获取栈顶元素**

```c
/*
 * @brief 获得栈顶元素
 * @param s 栈指针
 * @param data 存放栈顶元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int get_top_elem(SqStack *s, ElemType *data)
{
    if (NULL == s || NULL == data)
        return FALSE;
    //如果栈为空
    if (s->top == s->base)
    {
        printf("[%s %d] stack is empty ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    *data = *(s->top - 1);
    return TRUE;
}

```

7、求顺序栈的长度

```c
int get_len(SqStack s)
{
	if (NULL==s)
		return 0;
	return s->top-s->base;
}
```

**8、清空顺序栈**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/4706f925cdbb4583af11c55dcbecc839.png)

```c
/*
 * @brief 清除一个栈
 * @param s 栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int stack_clear(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }
    s->top = s->base;
    return TRUE;
}
```

**9、销毁顺序栈**

```c
 /*
 * @brief 销毁栈
 * @param s 栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int stack_destroy(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }

    if (s->base != NULL)
    {
        free(s->base);
        s->top = s->base = NULL;
        s->stackLen = 0;
    }
    return TRUE;
}
```

### 3.1.3 链式栈

链式栈就是使用链表的方式实现的栈，为了实现先进后出（FILO），我们可以采用链表中的“头插法”实现一个链式栈。

但是与之前所学的链表不同的是：链式栈中不需要头结点（数据域为空的结点）。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/abfa696f68f646099ffda9c1b682d339.png)

如上图所示，指向链表中的第一个结点的指针就是栈顶指针，指向链表最后一个结点的指针就是栈底指针。

**1、链式栈的描述**

```c
typedef struct StackNode{
    ElemType data; //数据域
    struct StackNode * next; //指针域
}StackNode, *LinkStack;
```

**2、链式栈的初始化**

```c
/*
 * @brief 初始化一个链式栈
 * @return 返回链式栈的栈顶指针
 * */
LinkStack stack_init()
{
    LinkStack s;
    //因为没有头结点，因此初始化链式栈时因为栈为空，所以栈顶指针赋值为NULL
    s = NULL; 
    return s;
}

```

**3、入栈**

入栈：链表的头插法，在链表的第一个结点之前插入新的结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/23421cf07a95412c994d7b570e71a8fd.png)

```c
/*
 * @brief 入栈
 * @param s 栈顶指针的地址
 * @param data 需要入栈的元素
 * @return 成功返回TRUE，失败返回FALSE
 * */
int push(LinkStack *s, ElemType data)
{
    if (NULL == s)
        return FALSE;

    StackNode *p = (StackNode *)malloc(sizeof(StackNode));
    p->data = data;

    //新的结点的next指向链表的第一个结点（原来的栈顶）
    p->next = *s;
    //栈顶指针指向新的结点（p变成了链表上的第一个结点）
    *s = p;
  
    return TRUE;
}

void print_stack(LinkStack s)
{
    if (NULL == s)
        return ;

    StackNode *t = s;
    while (t)
    {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
}
```

**4、出栈**

```c
/*
 * @brief 出栈
 * @param s 栈顶指针的地址
 * @param data 需要出栈的元素
 * @return 成功返回TRUE，失败返回FALSE
 * */
int pop(LinkStack *s, ElemType *data)
{
    if (NULL == s || NULL == data || NULL == *s)
        return FALSE;
  
    *data = (*s)->data;
    StackNode *t = (*s)->next;
    free(*s);
    *s = t;
    return TRUE;
}
```

**5、获取栈顶元素**

```c
/*
 * @brief 获取栈顶元素 
 * @param s 栈顶指针
 * @param data 需要入栈的元素
 * @return 成功返回TRUE，失败返回FALSE
 * */
int get_top(LinkStack s, ElemType *data)
{
    if (NULL == s || NULL == data)
        return FALSE;
    *data = s->data;

    return TRUE;
}
```

**6、销毁链式栈**

```c
/*
 * @brief  销毁链式栈
 * @param s 栈顶指针的地址
 * @return 成功返回TRUE，失败返回FALSE
 * */
int stack_destroy(LinkStack *s)
{
    if (NULL == s || NULL == *s)
        return FALSE;  

    StackNode *t = *s;;
    while (t)
    {
        t = (*s)->next; 
        free(*s);
        *s = t;
    }
    //*s = NULL;
    return TRUE;
}
```

### 3.1.4 栈的应用

**1、数值转换**

```c
void conversion()
{
    LinkStack s = stack_init();

    unsigned int num;
    printf("plz input A number to be converted : ");
    scanf("%d", &num);

    unsigned int N;
    printf("plz input decimal （2 8 16）：");
    scanf("%d", &N);

    char f;
    while (num)
    {
        if (num % N < 10)
            f = num % N + '0';//将一个10以内的整数转换成字符形式：例如  5 -> '5'
        else 
            f = num % N - 10 + 'A';// 10~15转换为 'A' ~ 'F' 

        push(&s, f);
        num = num / N;
    }

    //出栈
    while (is_empty(s) != TRUE)
    {
        pop(&s, &f);
        printf("%c", f);
    }
    printf("\n");
  
}
```

**2、括号匹配**

假设表达式中允许出现两种括号：圆括号()和方括号[]，其嵌套的顺序随意，即( [ ( ) ( ) ] )或者 [ ( [ ] [ ] ) ]等为正确的表达式，但是 ( [ ( ] ) 或者 [ ( [ ) ] 或者  ( [ ( ] ) )等为错误的表达式。检查括号是否匹配可以采用如下逻辑：

* 遍历整个表达式
* 如果是左括号入栈
* 如果是右括号则从栈中出栈一个括号，如果与右括号匹配则继续往后遍历，如果不匹配则说明是错误的表达式
* 如果表示遍历完毕，最后栈为空说明表达式正确否则说明表达式错误

```c
int brackets_match()
{
    char *str = (char *)malloc(100);

    LinkStack s = stack_init();

    printf("plz input expression: ");
    scanf("%s", str);

    int i = 0;
    char f;
    while (str[i] != '\0')
    {
        if (str[i] == '(' || str[i] == '[')
            push(&s, str[i]);
        else if (str[i] == ')')
        {
            pop(&s, &f);
            if (f != '(')
                return FALSE;
        }
        else if (str[i] == ']')
        {
            pop(&s, &f);
            if (f != '[')
                return FALSE;
        }
        i++;
    }

    if (is_empty(s) == TRUE)
        return TRUE;
    else
        return FALSE;
}
```

**3、 表达式求值**

**需求：输入一个表达式,含加减乘除括号运算，输出表达式的值**

例如：求20+(3*400)-100/3的值

逻辑：

* 使用两个栈，一个栈存放操作符，一个栈存放操作数
* 遍历整个表达式，如果是操作数入栈操作数栈
* 如果是操作符，则获取操作符栈的栈顶元素，比较两个操作符的优先级，如果比栈顶的操作符优先级低或者相等，则出栈一个操作符，出栈两个操作数，将计算结果入操作数栈
* 如果比栈顶的操作符优先级高则直接入栈操作符栈
* 如果遇到的是左括号 ( ， 则直接入栈操作符栈
* 如果是右括号 )，则从操作符栈出栈一个操作符，出栈两个操作数，将计算结果入操作数栈，直到将左括号出栈

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TRUE 0
#define FALSE -1

#define STACK_INIT_LEN 100
#define STACKINCREMENT 10

typedef unsigned int uint;
typedef int ElemType;

typedef struct SqStack{
    ElemType *top; //栈顶指针
    ElemType *base; //栈底指针
    uint stackLen; //分配的栈的长度
}SqStack;

int is_empty(SqStack *s)
{
    if (s->top == s->base)
        return TRUE;
    return FALSE;
}

/*
 * @brief 初始化一个顺序栈
 * @param 初始顺序栈的长度
 * @return 返回初始化后的栈的指针
 * */
SqStack *stack_init(uint size)
{
    //创建一个栈
    SqStack *s = (SqStack *)malloc(sizeof(SqStack));

    //为栈分配空间
    s->base = (ElemType *)malloc(size*sizeof(ElemType));
    s->top = s->base;
    s->stackLen = size;
    return s;
}

/*
 * @brief 对栈进行扩容
 * @param s 需要扩容的栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 */
int expand(SqStack *s)
{
    printf("[%s %d] stack expand ...\n", __FUNCTION__ , __LINE__);
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //为栈重新分配空间，栈底指针指向新的分配好的空间
    s->base = (ElemType *)realloc(s->base, (s->stackLen+STACKINCREMENT)*sizeof(ElemType));
    //栈顶指针指向新的栈顶元素
    s->top = s->base + s->stackLen;
    s->stackLen += STACKINCREMENT;

    return TRUE;
}

/*
 * @brief 入栈
 * @param s 栈指针
 * @param data 需要入栈的元素
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int push(SqStack *s, ElemType data)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }
    //如果栈满了
    if (s->top - s->base >= s->stackLen)
        expand(s);
    *(s->top) = data;
    s->top++;

    return TRUE;
}

/*
 * @brief 出栈
 * @param s 栈指针
 * @param data 存放栈顶元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int pop(SqStack *s, ElemType *data)
{
    if (NULL == s || NULL == data)
        return FALSE;
    //如果栈为空
    if (s->top == s->base)
    {
        printf("[%s %d] stack is empty ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }
    s->top--;
    *data = *(s->top);

    return TRUE;
}

/*
 * @brief 获得栈顶元素
 * @param s 栈指针
 * @param data 存放栈顶元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int get_top_elem(SqStack *s, ElemType *data)
{
    if (NULL == s || NULL == data)
        return FALSE;
    //如果栈为空
    if (s->top == s->base)
    {
        printf("[%s %d] stack is empty ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    *data = *(s->top - 1);
    return TRUE;
}

int print_stack(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }

    ElemType *t = s->top;
    t--;
    while (t != s->base)
    {
        printf("%d ", *t);
        t--;
    }
    printf("%d \n", *t);
    return TRUE;
}

/*
 * @brief 清除一个栈
 * @param s 栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int stack_clear(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }
    s->top = s->base;
    return TRUE;
}

/*
 * @brief 销毁栈
 * @param s 栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int stack_destroy(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }

    if (s->base != NULL)
    {
        free(s->base);
        s->top = s->base = 0;
        s->stackLen = 0;
    }
    return TRUE;
}

int cal_oper(int num2, int num1, char f)
{
    switch (f) {
        case '+':
            return num2 + num1;
        case '-':
            return num2 - num1;
        case '*':
            return num2 * num1;
        case '/':
            return num2 / num1;
    }
}

int cal_exp(SqStack *oper, SqStack *oprand)
{
    //出栈一个操作符
    char f;
    pop(oper, &f);
    //出栈两个操作数
    int num1, num2;
    pop(oprand, &num1);
    pop(oprand, &num2);
    int num =  cal_oper(num2, num1, f);
    return num;
}

int calculate()
{
    //操作符栈
    SqStack *oper = stack_init(STACK_INIT_LEN);
    //操作数栈
    SqStack *oprand = stack_init(STACK_INIT_LEN);

    char exp[128];
    memset(exp, 0, sizeof(exp));

    printf("plz input expression: ");
    scanf("%s", exp);

    int i;
    char f;
    int num;
    while (exp[i] != '\0') {
        //如果是数字则计算出该数字后直接入栈
        if (exp[i] >= '0' && exp[i] <= '9') {
            int num = 0;
            while (exp[i] >= '0' && exp[i] <= '9') {
                num = num * 10 + (exp[i] - '0');  i++;
            }
            //将操作数入栈
            printf("[%d] push: %d\n", __LINE__, num);   push(oprand, num);   continue;
        }
        //如果是左括号 直接入栈
        if (exp[i] == '('){ printf("[%d] push: %c\n", __LINE__, exp[i]);   push(oper, exp[i]);  i++;  continue; }

        //如果是右括号 从操作符栈出栈一个操作符，从操作数栈出栈两个操作数，计算后将结果入栈操作数栈
        if (exp[i] == ')'){
            while (is_empty(oper) != TRUE){
                get_top_elem(oper, &f);
                if (f != '('){
                    //从操作符栈出栈一个操作符，从操作数栈出栈两个操作数，计算后将结果入栈操作数栈
                    push(oprand, cal_exp(oper, oprand));
                    continue;
                }
                else{

                    pop(oper, &f);
                    break;
                }
            }
            i++; continue;
        }
        //如果是+ -
        if (exp[i]=='+' || exp[i]=='-'){
            //如果操作符栈为空直接入栈
            if (is_empty(oper)==TRUE) {
                printf("[%d] push: %c\n", __LINE__, exp[i]);
                push(oper, exp[i]); i++; continue;
            }
            while (is_empty(oper) != TRUE){//一直出栈操作符栈中的符号直到遇到(或者操作符栈为空
                //  先获取操作符栈顶元素，如果是左括号直接入栈
                get_top_elem(oper, &f);
                if (f=='(') { break;}
                //从操作符栈出栈一个操作符，从操作数栈出栈两个操作数，计算后将结果入栈操作数栈
                push(oprand,cal_exp(oper, oprand));
                continue;
            }
            //最后将遍历到的符号入栈操作符栈
            printf("[%d] push: %c\n", __LINE__, exp[i]);
            push(oper, exp[i]); i++; continue;
        }
        //如果是 * /
        if (exp[i]=='*' || exp[i]=='/'){
            //如果操作符栈为空直接入栈
            if (is_empty(oper)==TRUE) {
                printf("[%d] push: %c\n", __LINE__, exp[i]);
                push(oper, exp[i]); i++; continue;
            }
            while (is_empty(oper) != TRUE) {//一直出栈操作符栈中的符号直到遇到(或者操作符栈为空,或者+ -
                //  先获取操作符栈顶元素，如果是左括号 或者+ - 直接入栈
                get_top_elem(oper, &f);
                if (f == '(' || f == '+' || f == '-') {break;}
                //从操作符栈出栈一个操作符，从操作数栈出栈两个操作数，计算后将结果入栈操作数栈
                push(oprand,cal_exp(oper, oprand));
                continue;
            }
            //最后将遍历到的符号入栈操作符栈
            printf("[%d] push: %c\n", __LINE__, exp[i]);
            push(oper, exp[i]); i++; continue;
        }
    }
    //遍历完整个表达式后将操作符中的元素依次出栈
    while (is_empty(oper) != TRUE)
        push(oprand,cal_exp(oper, oprand));

    pop(oprand,&num);
    return num;
}

int main() {

    int num;
    num = calculate();
    printf("%d\n", num);
    return 0;
}
//10-5*(3+2)+6/2+10*(4/2)

```

## 3.2 队列

### 3.2.1 队列概述

**1、队列的基本概念**

队列是一种基**先进先出(FIFO)**的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/c2e6885c077841cabc262c8f61a875a6.png)

**2、队列的应用**

* 举例1：排队系统的实现
* 举例2：使用循环队列存储网络摄像头的数据帧（图像数据）

**3、队列的具体实现**

* **顺序队列**
* **链队列**

### 3.2.2 顺序队列

在实现顺序队列之前，我们先来看一看对于顺序队列的操作：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/1f1f14a747f24c5da72046da67c057ac.png)

顺序队列可以使用一维数组实现，在顺序队列中有两个指针，一个指针front指向队列的队首（数组的第0个元素），一个指针rear指向队列的队尾（最后一个放入队列的元素）。

**1、顺序队列的描述**

```从
#define QUEUE_INIT_LEN 100
#define QUEUEINCREMENT 10
typedef struct SqQueue
{
    ElemType *base; //存储堆上元素的地址空间的首地址
    uint front; //队首指针
    uint rear; //队尾指针
}SqQueue;
```

**2、关于顺序队列操作的思考**

* 如果对顺序队列进行出队操作，队首指针该如何移动？
  * 队首指针往后移动
* 对顺序队列进行出队操作后，被出队的元素所占用的空间怎处理？
  * 只能暂时空着，等待下次循环使用
  * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/c8a4e9859bf444e1ac2e31242525c355.png)
* 如何判断顺序队列是否为满，是否为空呢？
  * 判断队列为满和空的依据都是front == rear，因此会有冲突
* 如何判断队列是否溢出呢？
  * 当front为0，rear等于队列最大长度时为真溢出
    * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/2636af337be44ade8dde3b3a49c301fd.png)
  * 当front不为0，rear等于队列最大长度时为假溢出![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/48e917a6f9714c29ac6d37bef0d609fa.png)

解决方案：使用循环队列。

**3、循环队列的概念**

队列上的各个元素逻辑上形成一个圆环状。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/8aa7392a06b44fd3b8613795151041ca.png)

如何判断队列是否为满呢？

* 将队列上的一个位置作为空闲位置
* 假设队列的长度为M，当 （rear + 1）% M == font时，认为队列为满
  * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/2eaf680c47084770bdfc39b97dde5bf3.png)

**4、循环顺序队列的初始化**

```c
/*
 * @brief 初始化一个顺序队列
 * @param len 顺序队列的初始化长度（可以存储的元素的最大个数）
 * @return 返回初始化的顺序队列
 * */
SqQueue SqQueue_init(uint len)
{
    SqQueue s;
    s.base = (ElemType*)malloc(len*sizeof(ElemType));
    s.front = 0;
    s.rear = 0;
  
    return s;
}
```

**5、获取顺序队列的长度（实际存储的元素的个数）**

```c
/*
 * @brief 获取顺序队列的长度
 * @param s 顺序队列
 * @return 顺序队列的长度
 * */
int SqQueue_length(SqQueue s)
{
    return s.rear - s.front;
}

```

**6、判断顺序队列是否为空**

```c
/*
 * @brief 判断顺序队列是否为空
 * @param 顺序队列
 * @return 为空返回TRUE，不为空返回FALSE
 * */
int is_empty(SqQueue s)
{
    if (s.front == s.rear)
        return TRUE;
    else
        return FALSE;
}

```

**7、判断顺序队列是否为满**

```c
/*
 * @brief 判断顺序队列是否为满
 * @param 顺序队列
 * @return 为满返回TRUE，不为满返回FALSE
 * */
int is_full(SqQueue s)
{
    if ((s.rear+1)%QUEUE_INIT_LEN == s.front)
        return TRUE;
    else
        return FALSE;
}
```

**8、入队**

```c
/*
 * @brief 循环顺序队列入队
 * @param data 需要入队得元素
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int EnQueue(SqQueue *s, ElemType data)
{
    if (NULL == s)
        return FALSE;
    if (is_full(*s) == TRUE)
    {
        printf("[%s %d] queue is full ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    s->base[s->rear] = data;
    s->rear= (s->rear + 1) % QUEUE_INIT_LEN; //尾指针往后移动
    return TRUE;
}
```

**9、顺序队列打印**

```
/*
 * @brief 输出顺序队列中的元素
 * @param s 需要输出顺序队列
 * @return 成功返回TRUE，失败返回FALSE
 * */
int print_SqQueue(SqQueue s)
{
    if (is_empty(s) == TRUE)
    {
        printf("[%s %d] SqQueue is empty\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }
    int i = s.front;
    while (i != s.rear)
    {
        printf("%d ", s.base[i]);
        //i 指向下一个位置
        i = (i+1)%QUEUE_INIT_LEN;
    }
    printf("\n");
    return TRUE;
}
```

**10、出队**

```c
/*
 * @brief 循环顺序队列出队
 * @param data 存储出队元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int DeQueue(SqQueue *s, ElemType *data)
{
    if (NULL == s)
        return FALSE;
    if (is_empty(*s) == TRUE)
    {
        printf("[%s %d] queue is empty ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    *data = s->base[s->front];
    s->front = (s->front + 1) % QUEUE_INIT_LEN; //队首指针往后移动

    return TRUE;
}
```

### 3.3.2 链式队列

链式队列可以理解为对单向链表的操作，入队就是单向链表的尾插法，出队则需要销毁第一个数据结点（类似删除链表上的第一个数据结点）。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/9d98d0d2aa454491ab85bd02e57a460b.png)

```c++
#include <stdio.h>
#include <stdlib.h>

#define TRUE   0
#define FALSE -1

typedef int ElemType;
typedef unsigned int uint;

/*
 * 链式队列可以理解成一个通过尾插法创建的链表（可以带头结点也可以不带头结点）
 * */
//定义链表上的一个结点
typedef struct LNode
{
    ElemType data; //数据域
    struct LNode *next; //指向当前结点的下一个结点的指针（这个指针保存了下一个结点的存储位置）
}LNode;

//定义一个结构体描述一个链式队列
typedef struct LinkQueue
{
    LNode *front; //队首指针
    LNode *rear; //队尾指针
}LinkQueue;

/*
 * @brief 初始化一个链式队列
 * @return 代表链式队列的结构体
 * */
LinkQueue queue_init()
{
    //创建一个头结点
    LinkQueue L;
    //当队列为空时，队首指针和队尾指针都为NULL
    L.front = L.rear = NULL;

    return L;
}

/*
 * @brief 打印链式队列中的元素
 * @param L 链式队列结构体
 * @return
 * */
void print_queue(LinkQueue L)
{
    //使用临时指针指向链表上的第一个数据结点（就是头节点的下一个结点）
    LNode *tmp;
    tmp = L.front;

    while (tmp != NULL)
    {
        printf("%d ", tmp->data);
        //让tmp指针指向下一个结点
        tmp = tmp->next;
    }
    printf("\n");
}

/*
 * @brief 入队
 * @param L 链式队列的指针
 * @param data 需要插入的元素
 * @return 成功返回TRUE，失败返回FALSE
 * */
int EnQueue(LinkQueue *L, ElemType data)
{
    if (NULL == L)
        return FALSE;

    //先创建一个结点
    LNode *p = (LNode *)malloc(sizeof(LNode));
    p->data = data;
    p->next = NULL;

    //先判断队列是否为空队列
    if (L->front == NULL)
    {
        L->front = p;
        L->rear = p;

        return TRUE;
    }
    //如果队列不为空，那么将rear指向新的结点
    L->rear->next = p;
    L->rear = p;

    return TRUE;
}

int DeQueue(LinkQueue *L, ElemType *data)
{
    if (NULL == L || NULL == data)
        return FALSE;

    if (NULL == L->front)
        return FALSE;

    //首先保存链式队列上的第一个结点的值
    *data = L->front->data;
    //使用临时指针执行队首
    LNode *t = L->front;
    //队首指针指向后一个结点（出队后原来队列上的第二个结点变成了新的队首结点）
    L->front = L->front->next;
    //删除原来的队首结点
    free(t);

    return TRUE;
}

int main() {
    LinkQueue L;

    L = queue_init();

    int i;
    for (i = 0; i < 10; i++)
        EnQueue(&L, i);
    print_queue(L);

    ElemType data;
    while (DeQueue(&L, &data) != FALSE)
        printf("%d\n", data);
    return 0;
}

```

# 四、树

## 4.1 树的基本概念

树（Tree）是n（n>=0）个结点的有限集，它或为空树（n = 0）；或为非空树，对于非空树 T：

* 有且只有一个称之为根的结点
* 除根节点以外的其他结点可分为m（m>0）个互不相交的有限集T1, T2, T3 ...，Tm，其中每个结合本身也是一颗树，并且称之为根的子树（SubTree）

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/cce07ec47490412cafd46e6dbedaff39.png)

树的其他表示方法：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/ce260011633d421ba97d6a1a7112e5f3.png)

## 4.2 树的相关术语

**1、结点的度**

一个结点含有的**子树的个数**称为该结点的度。

**2、叶子结点**

**度为0**的结点称为叶结点，也可以叫做终端结点，**叶子结点没有直接后继。**

**3、分支结点**

度不为0的结点称为分支结点，也可以叫做非终端结点。

**4、结点的层次**

从根结点开始，**根结点的层次为1**，根的直接后继层次为2，以此类推。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/7150de59b89148c99d02c248fd8ed671.png)

**5、树的度**

树中所有结点的**度的最大值。**

**6、树的高度(深度)**

树中结点的最大层次。

**7、森林**

m（m>=0）个互不相交的树的集合，**将一颗非空树的根结点删去，树就变成一个森林**；给森林增加一个统一的根结点，森林就变成一棵树。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/07ce065ed57b4b649332c39006dba449.png)

**8、孩子结点**

一个结点的直接后继结点称为该结点的孩子结点。

**9、双亲结点(父结点)**

一个结点的直接前驱称为该结点的双亲结点。

**10、兄弟结点**

同一双亲结点的 孩子结点间互称兄弟结点。

## 4.3 二叉树

### 4.3.1 二叉树的概念

二叉树就是度不超过2的树(每个结点最多有两个子结点)。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/bde0db06f828423f8da70f7757ae8dd4.png)

### 4.3.2 二叉树的基本性质

**1、在二叉树的第i层上最多有 2^(i-1) 个结点**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/074c2e14ccf74daf8033943d63a53499.png)

**2、深度为K的二叉树最多有 2^k - 1个结点**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/fb8fd4f6f6b8430791c0130187ff3f33.png)

**3、深度为K时最少有K个结点（每层1个结点）**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/165031e8bfa143b79175b91a9e0b188a.png)

### 4.3.3 特殊形态的二叉树

**1、满二叉树**

一个二叉树，**每层的结点树都达到最大值**，则这个二叉树就是满二叉树。深度为K的满二叉树有 2^k - 1个结点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/ec882b2565044c10a77bd17e5fa2fd3f.png)

**2、完全二叉树**

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。

以下二叉树均为完全二叉树：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/1ecb1a96011448a18d03b056ded0f6bd.png)![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/dc33f88969e848ecb549e014a77daf70.png)

以下二叉不是完全二叉树：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d5ab9a2b49014257b517bd664312f4c3.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/e0f42954d9394644bb4a2026a88ac3ee.png)

**思考：假如一棵完全二叉树有n个结点，请问最后一个非叶子结点的编号是多少？**

**答案：n/2**

**思考：假如一棵完全二叉树的最后一个非叶子结点的编号为n，那么请问这棵二叉树有多少个结点？**

**答案：2n 或者 2n+1**

**思考：假如一棵完全二叉树有n个结点，请问叶子结点的个数是多少？**

**答案：n为偶数：n/2， n为奇数：n/2+1**

### 4.3.4 二叉树的遍历

在对二叉树元素进行访问、插入、删除等操作时，我们需要对二叉树进行遍历，所谓的遍历指按某条搜索路线遍访每个结点且不重复(又称周游)。

对二叉树的遍历可以按照如下两种思路进行：

* 广度遍历：按层次遍历
* 深度遍历：
  * 前序（先序）遍历：根结点 ---> 左子树 ---> 右子树
  * 中序遍历：左子树---> 根结点 ---> 右子树
  * 后序遍历：左子树 ---> 右子树 ---> 根结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/226cb2c11e384ea6b34946fe73006dcf.png)

> 二叉树经典笔试题:
>
> 假如已知对一棵二叉树的先序遍历为：FBACDEGH， 中序遍历为：ABDCEFGH，请问后序遍历的结果是什么？

### 4.3.5 二分查找树（二叉排序树）

**1、二分查找树的概念**

二分查找树BST（也叫二分查找树、二叉排序树）的提出是为了提供查找效率，之所以称为二分查找树，因为该二叉树对应着二分查找算法，查找平均的时间复杂度为O(logn)，所以该数据结构的提出是为了提高查找效率。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/3e592cfd5ac5485aa8a0c3b232ad2cb0.gif)

**2、二分查找树的性质**

二分查找树具有下列性质：

* 若它的左子树不为空，则左子树上所有结点的值均小于根结点的值
* 若它的右子树不为空，则右子树上所有结点的值均大于根结点的值
* 它的左右子树均为二分查找树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/acd0e475669149b090acd3909e64b6a1.png)

**3、二分查找树的中序遍历**

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/b2fbdf056cfc46449ff26944b58e20c9.png)

1->2->3->5->7->9->10->11->12->13->15

**4、二分查找树的插入**

* 遍历规则：
  * 从根节点开始遍历
  * 如果比遍历到的结点大，遍历该结点的右子树，如果右子树为空则将新的结点作为该结点的右子树
  * 如果比遍历到的结点小，遍历该结点的左子树，如果左子树为空则将新的结点作为该结点的左子树
* 将4插入到二分查找树中

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/77af56aeb7044127b4bda2b5292723b2.png)

**5、二分查找树结点的删除**

A：删除的结点是叶子结点，直接删除

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/3e1cebd20fce447f90b866603cc3103b.png)

B：有一个分支的，删除节点，子节点上提。

先找到需要删除的结点，将该结点删除

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/f8ed8cbde5bf4254b75db68eda185845.png)

上提子结点：

> 注意：不论需要删除的结点有左孩子结点还是右孩子结点，该结点上提后都是删除结点父结点的左孩子结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/2b45a51212a04e479bbf77a21cb3603f.png)

C：两个分支，节点删除，找到右子树的最小子树替换删除的结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/32a7af54438041fca252a3f27116a907.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/316a379a531646c59346468229e40226.png)

### 4.3.6 二分查找树

**1、结点描述**

* 二叉树的结点可以有至少有三个域：一个数据域，两个指针域分别指向该结点的左孩子结点和右孩子结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/bbada2ef96384fa3bee530a0b1b57e4a.png)

```c
//二叉树的一个结点
typedef struct Node{
    int data;//数据域
    struct Node *lChild;//指向左孩子的指针
    struct Node *rChild; //指向右孩子的指针
}Node;
```

* 二叉树的结点也可以有四个域：一个数据域，三个指针域分别指向该结点的左孩子结点、右孩子结点和父亲结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/37764183f8f64269a1a7ac6e9dacb982.png)

```c
//二叉树的一个结点
typedef struct Node{
    ElemType data;//数据域
    struct Node *lChild;//指向左孩子的指针
    struct Node *rChild; //指向右孩子的指针
    struct Node *parent; //指向父结点的指针
}Node;
```

我们可以定义一个结构体描述一棵二叉树：

```c
//描述一棵树
typedef struct Tree{
	 Node *root;//指针指向树的根结点
	//树的结点数
	u32t node_num; 
	//树的层次
	u32t level;
	//树的深度
	u32t deep; 
}Tree; 
```

**2、二分查找树的初始化**

```c
/*
 * @brief 创建一个结点
 * @param data 结点上数据域的值
 * @return 返回指向创建好的结点的指针
 * */
Node *create_node(ElemType data)
{
    Node *node;
    node = (Node *)malloc(sizeof(Node));

    node->data = data;
    node->lChild = NULL;
    node->rChild = NULL;

    return node;
}

/*
 * @brief 初始化一棵二叉树
 * @return 返回描述一棵二叉树的结构体指针
 * */
Tree *tree_init()
{
    Tree *t;
    t = (Tree *)malloc(sizeof(Tree));

    t->root = NULL;
    t->deep = 0;
    t->level = 0;
    t->node_num  = 0;
    return t;
}
```

**3、二分查找树的创建**

```c
/*
*	@brief 向树中插入一个结点，使这棵树成为一棵二分查找树 （前提：插入前该树就已经是一棵二分查找树）
*	@param root 二叉树的根节点指针
*	@param data 插入的结点上的数据域
*   @return 成功返回TRUE，失败返回FALSE
*/
int bst_tree(Node **root, int data)
{
    if (NULL == root || NULL == *root)
        return FALSE;
    //思路：将data 使用bst_tree方法插入到以某一个结点为根结点的树中
    //如果这棵树为空 则创建的结点就是这棵树的根结点
    if (NULL == *root)
    {
        Node *node;
        node = create_node(data);

        *root = node;
        return TRUE;
    }

    //如果data比根小则插入*root的左子树
    if (data < (*root)->data)
    {
        bst_tree(&((*root)->lChild), data);
    }
    //如果data比根大则插入*root的右子树
    else if (data > (*root)->data)
    {
        bst_tree(&((*root)->rChild), data);
    }
    else //如果相等则结束插入
        return TRUE;
}
```

**4、二分查找树的遍历**

```c
//以先序的方式遍历一棵树
void pre_traversal(Node *root)
{
    if (NULL == root)
        return ;

    printf("%d\n", root->data); //打印根结点上的数据
    pre_traversal(root->lChild);
    pre_traversal(root->rChild);
  
    return ;
}

//中序的方式遍历一棵树 左根右 
void infix_traversal(Node *root)
{
    if (NULL == root)
        return ;

    infix_traversal(root->lChild);
    printf("%d\n", root->data);
    infix_traversal(root->rChild);
    return ;
}

//后序的方式遍历一棵树
void epilogue_traversal(Node *root)
{
    if (NULL == root)
        return ;

    epilogue_traversal(root->lChild);
    epilogue_traversal(root->rChild);
    printf("%d\n", root->data);

    return ;
}
```

**5、查找二分查找树中的最小值**

```c
/*
 * @brief 查找二分查找树中的最小值
 * @param root 二叉树的根节点指针
 * @return 成功返回最小值，失败返回FALSE
 * */
ElemType find_min_node(Node *root)
{
    //因为是二分查找树，所以最小值是在最左边
    //如何找到最左边的那棵子树？从根结点开始遍历遍历所有的左子树的左子树
    //直到某棵树的左子树为空

    //非递归方法
//	Node *t = root;
//	while (t->lChild != NULL)
//		t = t->lChild;
//	return t->data; 

    if (NULL == root->lChild)
        return root->data;
    find_min_node(root->lChild);
}
```

**6、查找二分查找树中的最大值**

```c
/*
 * @brief 查找二分查找树中的最小值
 * @param root 二叉树的根节点指针
 * @return 成功返回最小值，失败返回FALSE
 * */
ElemType find_max_node(Node *root)
{
    //因为是二分查找树，所以最大值是在最右边
    //如何找到最右边的那棵子树？从根结点开始遍历遍历所有的右子树的右子树
    //直到某棵树的右子树为空
    if (NULL == root->rChild)
        return root->data;
    find_max_node(root->rChild);
}
```

**7、查找指定的结点**

```c
/*
 * @brief 返回二分查找树上指定的值所在的结点
 * @param root 二叉树的根节点指针
 * @param data 需要查找的结点的值
 * return 如果找到了则返回结点 如果没有找到则返回NULL
 * */
Node *find_element(Node *root, int data)
{
    //如果找不到
    if (NULL == root)
        return NULL;

    if (root->data == data)
        return root;
    if (data < root->data)
        find_element(root->lChild, data);
    else if (data > root->data)
        find_element(root->rChild, data);
}
```

**8、不使用递归实现：按照深度优先的中序遍历二叉树上的所有结点**

**思路：使用栈进行存储**

```
#include <stdio.h>
#include <stdlib.h>

#define TRUE 0
#define FALSE -1

typedef unsigned int uint;
typedef int ElemType ;

int sum = 0;
ElemType datas[1024];

//描述二分查找树的一个节点
typedef struct Node
{
    ElemType data; //数据域
    struct Node *lChild; //指向左子树的指针
    struct Node *rChild; //指向右子树的指针

    //记录结点被入栈的次数
    int cntFlag;
}Node;

#define STACK_INIT_LEN 10
#define STACKINCREMENT 10

typedef Node * ElemType1;
typedef struct SqStack{
    ElemType1 *top; //栈顶指针
    ElemType1 *base; //栈底指针，指向存储栈的空间的首地址
    uint stackLen; //栈能够存储的最大的元素的个数
    uint len; //保存实际存储的元素的个数
}SqStack;

/*
 * @brief 初始化一个顺序栈
 * @param 初始顺序栈的长度
 * @return 返回初始化后的栈的指针
 * */
SqStack *stack_init(uint size)
{
    //创建一个栈
    SqStack *s = (SqStack *)malloc(sizeof(SqStack));

    //栈分配存储空间
    s->base = (ElemType1 *)malloc(size * sizeof(ElemType1));
    s->top = s->base;

    s->stackLen = size;
    s->len = 0;

    return s;
}

/*
 * @brief 对栈进行扩容
 * @param s 需要扩容的栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 */
int expand(SqStack *s)
{
    printf("[%s %d] SqStack expand ...\n", __FUNCTION__ , __LINE__);
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //为栈的存储空间重新分配空间
    s->base = (ElemType1 *)realloc(s->base, (s->stackLen + STACKINCREMENT)*sizeof(ElemType1));

    s->top = s->base + s->stackLen;

    s->stackLen += STACKINCREMENT;

    return TRUE;
}

/*
 * @brief 入栈
 * @param s 栈指针
 * @param data 需要入栈的元素
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int push(SqStack *s, ElemType1 data)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //先判断栈是否为满
    if (s->top-s->base==s->stackLen)
    {
        printf("[%s %d] SqStack is FULL ..\n", __FUNCTION__ , __LINE__);
        //对顺序栈进行扩容
        expand(s);
    }
    //入栈
    *(s->top) = data;
    s->top++;
    //s->len++;
    return TRUE;
}

/*
 * @brief 出栈
 * @param s 栈指针
 * @param data 存放栈顶元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int pop(SqStack *s, ElemType1 *data)
{
    if (NULL == s || NULL == data)
    {
        printf("[%s %d] stack pointer is NULL ...\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //先让栈顶指针--，指向栈顶的元素
    s->top--;
    *data = *(s->top);

    return TRUE;
}


//遍历整个栈
int print_stack(SqStack *s)
{
    ElemType1 *t = s->top;
    while (t != s->base)
    {
        t--;
        printf("%d ", *t);
    }

    printf("\n");
}

//判断栈是否为空，如果为空返回TRUE，如果不为空返回FALSE
int is_empty(SqStack *s)
{
    if (s->top == s->base)
        return TRUE;
    return FALSE;
}

/*
 * @brief 清除一个栈
 * @param s 栈指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int stack_clear(SqStack *s)
{
    if (NULL == s)
    {
        printf("[%s %d] stack pointer is NULL ...\n");
        return FALSE;
    }
    s->top = s->base;
    return TRUE;
}

/*
 * @brief 获得栈顶元素
 * @param s 栈指针
 * @param data 存放栈顶元素的指针
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int get_top_elem(SqStack *s, ElemType1 *data) {
    if (NULL == s || NULL == data)
        return FALSE;

    //获取栈顶元素
    *data = *(s->top-1);
    return TRUE;
}

//描述一棵二分查找树
typedef struct Tree
{
    Node *root; //指向二分查找树的根节点的指针
}Tree;

/*
 * @brief 初始化一棵二分查找树
 * @return 返回二分查找树的指针
 * */
Tree* tree_init()
{
    Tree *t;
    t = (Tree *)malloc(sizeof(Tree));

    t->root = NULL;

    return t;
}

/*
 * @brief 创建一个新的结点
 * @param data 结点的数据域的值
 * @return 返回新创建的结点的地址
 * */
Node *create_node(ElemType data)
{
    Node *t = (Node *)malloc(sizeof(Node));

    t->data = data;
    t->lChild = NULL;
    t->rChild = NULL;
    t->cntFlag = 0;
    return t;
}

/*
 * @brief 插入一个结点，保持插入后的二分查找树依然是一棵二分查找树
 * @param root 二分查找树的根节点指针的地址（二级指针）
 * @param data 插入的结点上数据域的值
 * @return 成功返回TRUE， 失败返回FALSE
 * */
int bst_tree(Node **root, ElemType data)
{
    if (NULL == root)
    {
        printf("[%s %d] root is NULL\n", __FUNCTION__ , __LINE__);
        return FALSE;
    }

    //创建一个新的结点
    Node *t = create_node(data);

    //判断树是否为一棵空树，如果是一颗空树，新插入的结点就是树的根节点
    if (NULL == *root)
    {
        *root = t; //根节点指针指向新的结点
        return TRUE;
    }
#if 0
    //和根节点比较大小，如果比根节点小，插入到根节点的左子树中
    if (data < (*root)->data)
    {
        bst_tree(&((*root)->lChild), data);
    }
    else if (data > (*root)->data) //和根节点比较大小，如果比根节点大，插入到根节点的右子树中
    {
        bst_tree(&((*root)->rChild), data);
    } else
        return FALSE;
#endif

    //定义一个临时变量用来遍历二分查找树
    Node *tmp = *root;

    while (1)
    {
        //如果比遍历到的结点要小
        if (data < tmp->data)
        {
            //如果该结点恰好没有左子树，将新的结点当作该节点的左子树
            if (NULL == tmp->lChild)
            {
                tmp->lChild = t;
                break;
            }
            else//如果该结点有左子树，继续遍历该结点的左子树
            {
                tmp = tmp->lChild;
                continue;
            }
        }
        else if (data > tmp->data)//如果比遍历到的结点要大
        {
            //如果该结点恰好没有右子树，将新的结点当作该节点的右子树
            if (NULL == tmp->rChild)
            {
                tmp->rChild = t;
                break;
            }
            else//如果该结点有右子树，继续遍历该结点的右子树
            {
                tmp = tmp->rChild;
                continue;
            }
        } //如果与遍历到的结点相等
        else
        {
            return FALSE;  //退出遍历
        }

    }
    return TRUE;
}

//以先序的方式遍历一棵树
void pre_traversal(Node *root)
{
    if (NULL == root)
        return ;

    printf("%d\n", root->data); //打印根结点上的数据
    datas[sum] = root->data;
    sum++;
    pre_traversal(root->lChild);
    pre_traversal(root->rChild);

    return ;
}

//以非递归方式，先序的方式遍历一棵树
void pre_traversal1(Node *root)
{
    if (NULL == root)
        return ;

    //初始化一个栈
    SqStack *s = stack_init(STACK_INIT_LEN);

    //定义一个临时指针 遍历
    Node *tmp = root;
    while (1)
    {
        //如果栈为空并且出栈的结点的左子树和右子树全部为空 结束遍历
        if (is_empty(s)==TRUE && tmp->lChild==NULL && tmp->rChild==NULL)
        {
            printf("%d ", tmp->data);
            break;
        }

        //先将根节点的数据域打印出来
        printf("%d ", tmp->data);
        //将结点的右子树入栈
        if (tmp->rChild != NULL)
            push(s, tmp->rChild);
        //将结点的左子树入栈
        if (tmp->lChild != NULL)
            push(s, tmp->lChild);

        //出栈一个结点
        pop(s, &tmp);
    }
    printf("\n");
}

//中序的方式遍历一棵树 左根右
void infix_traversal(Node *root)
{
    if (NULL == root)
        return ;

    infix_traversal(root->lChild);
    printf("%d\n", root->data);
    datas[sum] = root->data;
    sum++;
    infix_traversal(root->rChild);
    return ;
}

//非递归方式 中序的方式遍历一棵树 左根右
void infix_traversal1(Node *root)
{
    if (NULL == root)
        return ;

    //初始化一个栈
    SqStack *s = stack_init(STACK_INIT_LEN);

    //定义一个临时指针 遍历
    Node *tmp = root;
    while (1)
    {
        //一直往左边遍历，只要遍历到的结点的左子树不为空，入栈
        while (tmp)
        {
            push(s, tmp);
            tmp = tmp->lChild;
        }

        if (is_empty(s) != TRUE)
        {
            //出栈
            pop(s, &tmp);
            printf("%d ", tmp->data);
            tmp = tmp->rChild;
        } else
        {
            break;
        }
    }
    printf("\n");
}

//后序的方式遍历一棵树
void epilogue_traversal(Node *root)
{
    if (NULL == root)
        return ;

    epilogue_traversal(root->lChild);
    epilogue_traversal(root->rChild);
    printf("%d\n", root->data);
    datas[sum] = root->data;
    sum++;
    return ;
}

//后序的方式遍历一棵树
void epilogue_traversal1(Node *root)
{
    if (NULL == root)
        return ;

    //初始化一个栈
    SqStack *s = stack_init(STACK_INIT_LEN);

    //定义一个临时指针 遍历
    Node *tmp = root;
    while (1)
    {
        //一直往左边遍历，只要遍历到的结点的左子树不为空，入栈
        while (tmp)
        {
            tmp->cntFlag++;
            push(s, tmp);
            tmp = tmp->lChild;
        }

        if (is_empty(s) != TRUE)
        {
            //出栈
            pop(s, &tmp);
            //判断该结点是否被入栈了两次
            if (tmp->cntFlag < 2)
            {
                tmp->cntFlag++;
                push(s, tmp); //重新入栈
                //遍历这个结点的右子树
                tmp = tmp->rChild;
            } else
            {
                tmp->cntFlag = 0;
                printf("%d ", tmp->data);
                tmp = NULL;
            }
        } else
            break;
    }
    printf("\n");
}

/*
 * @brief 查找二分查找树的最小值
 * @param root 树的根节点指针
 * @return 最小值
 * */
ElemType find_min(Node *root)
{
    if (NULL == root)
        return -1;

    //从根节点开始遍历，一直遍历左子树，直到某个结点的左子树为空
#if 0
    //非递归方式
    Node *tmp = root;
    while (tmp->lChild != NULL)
    {
        tmp = tmp->lChild;
    }
    return tmp->data;
#endif
    if (NULL == root->lChild)
        return root->data;
    find_min(root->lChild);
}

/*
 * @brief 查找二分查找树的最大值
 * @param root 树的根节点指针
 * @return 最大值
 * */
ElemType find_max(Node *root)
{
    if (NULL == root)
        return -1;

    //从根节点开始遍历，一直遍历右子树，直到某个结点的右子树为空
#if 1
    //非递归方式
    Node *tmp = root;
    while (tmp->rChild != NULL)
    {
        tmp = tmp->rChild;
    }
    return tmp->data;
#endif
#if 0
    if (NULL == root->rChild)
        return root->data;
    find_max(root->rChild);
#endif
}

/*
 * @brief 查找二分查找树中指定的结点
 * @param root 根节点
 * @param data 需要查找的结点的值
 * @return 成功返回查找到的结点的地址，失败返回NULL
 * */
Node *find_elem(Node *root, ElemType data)
{
    if (NULL == root)
    {
        printf("[%s %d] can not find element: %d\n", __FUNCTION__ , __LINE__, data);
        return NULL;
    }

#if 0
    Node *tmp = root;
    while (1)
    {
        //从根节点开始遍历，如果比遍历到的节点小
        if (data < tmp->data)
        {
            if (tmp->lChild == NULL) //并且该该节点没有左子树，认为结点不在树上
            {
                printf("[%s %d] can not find element: %d\n", __FUNCTION__ , __LINE__, data);
                return NULL;
            }
            else  //如果比遍历到的节点小并且该该节点有左子树，继续遍历左子树
            {
                tmp = tmp->lChild;
                continue;
            }
        }
        else if (data > tmp->data)//如果比遍历到的节点大
        {
            if (NULL == tmp->rChild) //并且该节点没有右子树，认为结点不在树上
            {
                printf("[%s %d] can not find element: %d\n", __FUNCTION__ , __LINE__, data);
                return NULL;
            }
            else   //如果比遍历到的节点大并且该节点有右子树，继续遍历右子树
            {
                tmp = tmp->rChild;
                continue;
            }
        } else  //如果跟遍历到的结点相等，找到
        {
            return tmp;
        }
    }
#endif

    if (data == root->data)
        return root;
    if (data < root->data)
        find_elem(root->lChild, data);
    else if (data > root->data)
        find_elem(root->rChild, data);
}

int main() {

    printf("%f\n", 3/2);
    //初始化一颗二分查找树
    Tree *t;
    t = tree_init();

    bst_tree(&(t->root), 9);
    bst_tree(&(t->root), 5);
    bst_tree(&(t->root), 13);
    bst_tree(&(t->root), 2);
    bst_tree(&(t->root), 7);
    bst_tree(&(t->root), 12);
    bst_tree(&(t->root), 15);
    bst_tree(&(t->root), 14);
    bst_tree(&(t->root), 4);
#if 0
    infix_traversal(t->root);

    int i;
    for (i = 0; i < sum; i++)
        printf("%d ", datas[i]);
    printf("\n");

    sum = 0;

    printf("min: %d\n", find_min(t->root));

    printf("max: %d\n", find_max(t->root));

    Node *tmp;
    tmp = find_elem(t->root, 13);
    if (tmp != NULL)
        printf("yes\n");
    else
        printf("no\n");
#endif

    //使用非递归的方式先序遍历
    pre_traversal1(t->root);
    infix_traversal1(t->root);
    epilogue_traversal1(t->root);
    return 0;
}
```

**9、不使用递归实现：按照层次遍历二叉树上的所有结点**

**思路：使用队列进行存储**

```c
void travel(Tree *tree, List *queue)
{
	if (NULL == tree || NULL == queue)
		return;

	//用一个临时指针指向树的根结点
	TreeNode *root = tree->root;

	while (1)
	{
		printf("%d ", root->data);

		if (root->lChild==NULL && root->rChild==NULL && is_empty(queue))
			break;
		//判断是否有左子树
		if (root->lChild != NULL)
			enqueue(queue, root->lChild); 
		//判断是否有右子树 
		if (root->rChild != NULL)
			enqueue(queue, root->rChild); 

		//从队列上出队
		root = dequeue(queue); 
	} 
}
```

## 4.4 平衡二叉树

### 4.4.1 平衡二叉树概述

**1、引入**

之前我们学习过二叉查找树，发现它的查询效率比单纯的链表和数组的查询效率要高很多，最理想的情况下时间复杂度可以达到O(logn)，大部分情况下，确实是这样的，但不幸的是，在最坏情况下，二叉查找树的性能还是很糟糕。

例如我们依次往二叉查找树中插入9,8,7,6,5,4,3,2,1这9个数据，那么最终构造出来的树是长得下面这个样子：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/6d098583f3e54807ab70b33adb4658a6.png)

在极端的情况下，二分查找树可能会退化成为链表，我们会发现，如果我们要查找1这个元素，查找的效率依旧会很低。效率低的原因在于这个树并不平衡，全部是向左边分支，如果我们能够把这棵二分查找数进行调整让左右子树的高度相等，并且左右子树的结点数也趋近于相等，那么查找效率就会大大提高，我们可以将这棵树调整成为一棵平衡二叉树。

**2、平衡二叉树的概念**

平衡二叉树是一种二叉排序树，其中**每一个结点的左子树和右子树的高度差至多等于1**，**平衡二叉树又称为AVL树**。平衡二叉树是一种高度平衡的二叉排序树，意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/f6dd0ade7d95477584a301c5b0914f8a.png)

**3、平衡因子**

平衡因子（BF，Balance Factor 而不是 Boy Friend）指的是：左子树和右子树高度差。**一般来说 BF 的绝对值大于 1，,平衡树二叉树就失衡，需要「旋转」纠正**。

**4、最小失衡子树/最小不平衡子树**

**距离插结点点最近的**，并且 **BF 的绝对值大于 1** 的结点为根节点的子树叫做最小失衡子树。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/c1cb258e82044707a9483a7ba9e07f79.png)

### 4.4.2 平衡二叉树的旋转

**1、2 种「旋转」方式：**

* 左旋

  * 旧根节点为新根节点的左子树
  * 新根节点的左子树（如果存在）为旧根节点的右子树
* 右旋：

  * 旧根节点为新根节点的右子树
  * 新根节点的右子树（如果存在）为旧根节点的左子树

**2、4 种「旋转」纠正类型：**

* LL 型：插入左孩子的左子树，右旋
* RR 型：插入右孩子的右子树，左旋
* LR 型：插入左孩子的右子树，先左旋，再右旋
* RL 型：插入右孩子的左子树，先右旋，再左旋

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/0a9ef6bf04eb4a6e857c60565681fa09.png)

**3、LL 型失衡「右旋」**

第三个节点「1」插入的 时候，BF(3) = 2，BF(2) = 1 LL 型失衡，右旋，**根节点顺时针旋转。**

* 旧根节点（节点 3）为新根节点（节点 2）的右子树
* 新根节点的  **右子树** （如果存在）为旧根节点的左子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/1c04a2587c3949f9b07be022203afd53.gif)

**4、RR 型失衡「左旋」**

第三个节点「3」插入的 时候，BF(1)=-2 BF(2)=-1，RR 型失衡，左旋，**根节点逆时针旋转**。

* 旧根节点（节点 1）为新根节点（节点 2）的左子树
* 新根节点的左子树（如果存在）为旧根节点的右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/be95b15308b24766a45a007db4fa213b.gif)

**5、LR型**

第三个节点「3」插入的 时候，BF(3)=2 BF(1)=-1 LR 型失衡，**先「左旋」再「右旋」**。

左旋：

* 旧根节点（节点 1）为新根节点（节点 2）的左子树
* 新根节点的左子树（如果存在）为旧根节点的右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/6d987ace90e443b9978a0ec0d7b906f5.gif)

右旋：

* 旧根节点（节点 3）为新根节点（节点 2）的右子树
* 新根节点的 右子树（如果存在）为旧根节点的左子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/ec99c98284e6420c9951138425ee9e05.gif)

**6、RL型**

第三个节点「1」插入的 时候，BF(1)=-2 BF(3)=1 RL 型失衡，**先「右旋」再「左旋」**

右旋：

* 旧根节点（节点 3）为新根节点（节点 2）的右子树
* 新根节点的 右子树（如果存在）为旧根节点的左子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/44e8c65ce02d42f6ba5d80be8af9c219.gif)

左旋：

* 旧根节点（节点 1）为新根节点（节点 2）的左子树
* 新根节点的左子树（如果存在）为旧根节点的右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/9dc7874179c84599820f75f5a091047c.gif)

**7、实例**

接下来我们以 {3,2,1,4,5,6,7,10,9,8} 为实例练习刚刚的 4 种插入方式。

（1）依次插入 3、2、1 插入第三个点 1 的时候 BF(3)=2 BF(2)=1，LL 型失衡，右旋：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/c77dce3a43e64a59a3ba42c13aeb32bf.png)

（2）依次插入 4 ，5 插入 5 点的时候 BF(3) = -2 BF(4)=-1，RR 型失衡，左旋：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/10f239c70fa64847ae74c81fde16845a.png)

（3）插入 4 ，5 插入 5 点的时候 BF(2)=-2 BF(4)=-1 ，RR 型失衡 对最小不平衡树进行「左旋」

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/21218df1e3fa4649a0f175653274fe37.png)

新根节点（节点 4）的左子树（节点 3）为旧根节点的右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/ae2fdb885e3d474bb935e76e84f33dca.png)

（4）

插入 7 节点的时候 BF(5)=-2, BF(6)=-1 ，RR 型失衡，对最小不平衡树 进行「左旋」：![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/4d4c4f9670e644619bb808077432450a.png)

（5）依次插入 10 ，9 。插入 9 点的时候 BF(10) = 1，BF(7) = -2 ，RL 型失衡，对先「右旋」再「左旋」：

* 右子树先「右旋」

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/1736b4baacbe4414be66ba2ce89e35de.png)

* 最小不平衡子树再左旋：![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/0fbdcacdc293410bbe8962e96beffa68.png)

（6）最后插入节点 8 ，BF(6)=-2 BF(9)=1，RL 型失衡，先「右旋」再「左旋」：

* 最小不平衡子树的右子树 {9,7,10,8} 先「右旋

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/7259d51ddc0946bebb1dd4f0d1f828e8.png)
* 最小不平衡子树 {6,5,7,9,8,10} 再「左旋」

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/293a2bb4e84f4df0846b991f957df085.png)

* 左旋结束

  ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/dc343b5ca7c34910bca9ee06723311cf.png)

## 4.5 红黑树

**1、红黑树的概念**

红黑树也叫 R-B Tree，全称是Red-Black Tree，它一种特殊的二叉查找树。**红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)**。

**红黑树的特性:**
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/65033b95b55846d6bc2416c554fec7e8.png)

**2、红黑树的应用**

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。
例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

3、红黑树代码

```c
#include <stdio.h>
#include <stdlib.h>
const int RED = 0;
const int BLACK = 1;

struct rb_node{
    rb_node* lchild, *rchild, *parent;
    int key, colour;
};
rb_node* root;

rb_node* get_node(rb_node* parent, int key);
void rb_insert(int key);
rb_node* rb_search(int key);
void rb_delete(int key);
rb_node* clock_wise(rb_node* node);
rb_node* counter_clock_wise(rb_node* node);
void show_rb_tree(rb_node* node);

rb_node* get_node(rb_node* parent, int key){
    rb_node *tmp = (rb_node*)malloc(sizeof(rb_node));
    tmp->key = key;
    tmp->colour = RED;
    tmp->parent = parent;
    tmp->lchild = tmp->rchild = NULL;
    return tmp;
}

rb_node* clock_wise(rb_node* node){
    if(node == NULL || node->lchild == NULL)
        return NULL;

    rb_node *rb_1=node, *rb_2=node->lchild, *rb_3=node->lchild->rchild;
    if(rb_1->parent != NULL){
        if(rb_1->parent->lchild == rb_1)
            rb_1->parent->lchild = rb_2;
        else
            rb_1->parent->rchild = rb_2;
    }else if(rb_1 == root){
        root = rb_2;
    }
    rb_2->parent = rb_1->parent;

    rb_1->parent = rb_2;
    rb_2->rchild = rb_1;

    rb_1->lchild = rb_3;
    if(rb_3 != NULL)rb_3->parent = rb_1;

    return rb_2;
}

rb_node* counter_clock_wise(rb_node* node){
    if(node == NULL || node->rchild == NULL)
        return NULL;

    rb_node *rb_1=node, *rb_2=node->rchild, *rb_3=node->rchild->lchild;
    if(rb_1->parent != NULL){
        if(rb_1->parent->lchild == rb_1)
            rb_1->parent->lchild = rb_2;
        else
            rb_1->parent->rchild = rb_2;
    }
    else if(rb_1 == root){
        root = rb_2;
    }
    rb_2->parent = rb_1->parent;

    rb_1->parent = rb_2;
    rb_2->lchild = rb_1;

    rb_1->rchild = rb_3;
    if(rb_3 != NULL)rb_3->parent = rb_1;

    return rb_2;
}

rb_node* rb_search(int key){
    rb_node *p = root;
    while(p != NULL){
        if(key < p->key)
            p = p->lchild;
        else if(key > p->key)
            p = p->rchild;
        else
            break;
    }
    return p;
}

void rb_insert(int key){
    rb_node *p=root, *q=NULL;

    if(root == NULL){
        root = get_node(NULL, key);
        root->colour = BLACK;
        return;
    }

    while(p != NULL){
        q = p;
        if(key < p->key)
            p = p->lchild;
        else if(key > p->key)
            p = p->rchild;
        else return;
    }

    if(key < q->key)
        q->lchild = get_node(q, key);
    else
        q->rchild = get_node(q, key);

    while(q != NULL && q->colour == RED){
        p = q->parent;//p won't null, or BUG.

        if(p->lchild == q){
            if(q->rchild != NULL && q->rchild->colour == RED)
                counter_clock_wise(q);
            q = clock_wise(p);
            q->lchild->colour = BLACK;
        }
        else{
            if(q->lchild != NULL && q->lchild->colour == RED)
                clock_wise(q);
            q = counter_clock_wise(p);
            q->rchild->colour = BLACK;
        }

        q = q->parent;
    }
    root->colour = BLACK;
}

void show_rb_tree(rb_node* node){
    if(node == NULL)
        return;
    printf("(%d,%d)\n", node->key, node->colour);
    if(node->lchild != NULL){
        printf("[-1]\n");
        show_rb_tree(node->lchild);
    }
    if(node->rchild != NULL){
        printf("[1]\n");
        show_rb_tree(node->rchild);
    }
    printf("[0]\n");
}

void rb_delete(int key){
    rb_node *v = rb_search(key), *u, *p, *c, *b;
    int tmp;
    if(v == NULL) return;

    u = v;
    if(v->lchild != NULL && v->rchild != NULL){
        u = v->rchild;
        while(u->lchild != NULL){
            u = u->lchild;
        }
        tmp = u->key;
        u->key = v->key;
        v->key = tmp;
    }

    //u is the node to free.
    if(u->lchild != NULL)
        c = u->lchild;
    else
        c = u->rchild;

    p = u->parent;
    if(p != NULL){
        //remove u from rb_tree.
        if(p->lchild == u)
            p->lchild = c;
        else
            p->rchild = c;
    }
    else{
        //u is root.
        root = c;
        free((void*)u);
        return;
    }

    //u is not root and u is RED, this will not unbalance.
    if(u->colour == RED){
        free((void*)u);
        return;
    }

    free((void*)u);
    u = c;

    //u is the first node to balance.
    while(u != root){
        if(u != NULL && u->colour == RED){
            //if u is RED, change it to BLACK can finsh.
            u->colour = BLACK;
            return;
        }

        if(u == p->lchild)
            b = p->rchild;
        else
            b = p->lchild;

        printf("%d\n", b->key);

        //b is borther of u. b can't be null, or the rb_tree is must not balance.
        if(b->colour == BLACK){
            //If b's son is RED, rotate the node.
            if(b->lchild != NULL && b->lchild->colour == RED){
                if(u == p->lchild){
                    b = clock_wise(b);
                    b->colour = BLACK;
                    b->rchild->colour = RED;

                    p = counter_clock_wise(p);
                    p->colour = p->lchild->colour;
                    p->lchild->colour = BLACK;
                    p->rchild->colour = BLACK;
                }
                else{
                    p = clock_wise(p);
                    p->colour = p->rchild->colour;
                    p->rchild->colour = BLACK;
                    p->lchild->colour = BLACK;
                }

                return;
            }
            else if(b->rchild != NULL && b->rchild->colour == RED){
                if(u == p->rchild){
                    b = counter_clock_wise(b);
                    b->colour = BLACK;
                    b->lchild->colour = RED;

                    p = clock_wise(p);
                    p->colour = p->rchild->colour;
                    p->rchild->colour = BLACK;
                    p->lchild->colour = BLACK;
                }
                else{
                    p = counter_clock_wise(p);
                    p->colour = p->lchild->colour;
                    p->lchild->colour = BLACK;
                    p->rchild->colour = BLACK;
                }
                return;
            }
            else{//if b's sons are BLACK, make b RED and move up u.
                b->colour = RED;
                u = p;
                p = u->parent;
                continue;
            }
        }
        else{
            if(u == p->lchild){
                p = counter_clock_wise(p);
                p->colour = BLACK;
                p->lchild->colour = RED;
                p = p->lchild;
            }
            else{
                p = clock_wise(p);
                p->colour = BLACK;
                p->rchild->colour = RED;
                p = p->rchild;
            }
        }
    }
    root->colour = BLACK;
}

int main(){
    int i;
    root = NULL;
    for(i = 1; i <= 10; i++){
        rb_insert(i);
    }
    rb_delete(9);
    rb_delete(3);
    rb_delete(7);
    show_rb_tree(root);
    printf("\n");
    return 0;
}
```

## 4.6 哈夫曼树

思考：加入在网络通信中，我们需要将一篇英文文章发送给通信的另一方，在带宽一定的前提下，如何做到尽快传输呢？

### 4.6.1 哈夫曼树概述

**1、哈夫曼树的概念**

当用 n 个结点（**都做叶子结点**且都**有各自的权值**）试图构建一棵树时，如果构建的这棵树的**带权路径长度最小**，称这棵树为“**最优二叉树**”。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/9671637bf26e4b769ea1e987bd2dd467.png)

**2、哈夫曼树相关术语**

* **路径和路径长度**
  * 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径（在上图种，从根结点到结点 a 之间的通路就是一条路径。）。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1（上图中从根结点到结点 c 的路径长度为 3。）；
* **结点的权**
  * 给每一个结点赋予一个新的数值，被称为这个结点的权。“权”一般代表“重要度”、概率等，我们形象的用一个具体的数字来表示，然后通过数字的大小来决定谁重要，谁不重要，谁的概率大，谁的概率低。
* **结点的带权路径长度**
  * 结点到根结点的路径长度乘以该节点的权（上图中结点 b 的带权路径长度为 2 * 5 = 10 ）。
* **树的带权路径长度**
  * 树中各个叶结点的路径长度*该叶节点的权的和（各叶子结点的带权路径长度之和）*，常用WPL(Weight Path Length)表示。
  * 上图所示的这颗树的带权路径长度为：WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3

### 4.6.2 哈夫曼树的构建方法

第一步： 我们将所有的节点都作为独根结点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/36c6f3b74f6f47e48cda1b54e2c62101.png)

第二步： 我们将最小的两个结点C和A组建为一个新的二叉树，权值为左右结点之和。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/adc8abcd584c422abfe70bf433b422d4.png)

第三步： 将上一步组建的新节点加入到剩下的节点中，排除上一步组建过的左右子树，我们选中B组建新的二叉树，然后取权值。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/b3e75dd6a9d443c7966419a3ed95db90.png)

第四步： 同上。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/f45639da0371408db0843c983bd9de7e.png)

练习：请根据哈夫曼树的构建方法将以下结点构建成一棵哈夫曼树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/5ec7005969e8437b995856529beae1c7.png)

### 4.6.3 哈夫曼树的访问

* 当哈夫曼树构造好以后，我们该如何访问到哈夫曼树上的叶子结点呢？
  * 当我们在构造哈夫曼树时可以通过一定的的方法获取到每个叶子结点从根节点开始的访问路径，如果向左记为0，向右记为1，最终每个结点都可以用若干个0 1组成一个编码，该编码我们称之为“**哈夫曼编码**”。
* 假如有如下哈夫曼树
  * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/68384777877343889a482cbca5a35dec.png)
    每个叶子结点的哈夫曼编码为：
  * ![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/863fce2dcb814664961e525f357ce801.png)

### 4.6.3 哈夫曼树的应用

哈夫曼编码是一种编码方式，可以用于无损数据压缩。编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/c39ba923d69644d3a4fa2665f2efdf25.png)

数据在传输时只需要传输对应的哈夫曼编码即可，例如：发送 statespteasi，我们仅需要发送如下哈夫曼编码：

> **110111100111110010011100101111101100**

如果我们发送哈夫曼编码给接收方，接收方该如何解码呢？

* 通过一定的手段重构哈夫曼树
* 发送方将哈夫曼树提前发送给接收方

## 4.7 B树

### 4.7.1 B树的基本概念

B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插入和删除等操作。

假如当前有一颗m阶的B树（注意阶的意思是指每个节点的孩子节点的个数），那么其符合：

（1）每个节点最多有m个子节点

（2）除了根节点和叶子节点之外，其他的每个节点最少有m/2（向上取整）个孩子节点

（3）根节点至少有两个孩子节点，（除了第一次插入的时候，此时只有一个节点，根节点同时是叶子节点）

（4）所有的叶子节点都在同一层

（5）有k个子节点的父节点包含k-1个关键码

除了上面B树的性质外，B树还有几个特点：

1，树高平衡，所有的叶节点都在同一层

2，关键码没有重复，父节点中的关键码是其子节点的分解

3，B树保证树种至少有一部分比例的节点是满的。为什么这样说，在上面的性质2中，我们知道每个节点最少可以有 m/2个节点，注意这刚好是一半，没有太满，是因为可以给后续的添加，删除留有余地，这样以来节点不会频繁的触发不平衡，没有太空则意味着B树能够 保证降低树的高度。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/3a34c83458ba4407b50e23b5f719e5f3.png)

### 4.7.2 B树的插入

**插入规则：在叶子结点上插入结点**

假设现在构建一棵**四阶B树**，开始插入“30”，直接作为根节点，

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/0b472180cb6c49c0855f04586eba79da.png)

插入“60”，大于“30”，放右边，

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/ee2b4f02b72048a5bf42d083fc8adb8f.png)

插入“90”，大于“60”，放右边，

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/87790b927e1146448b6e04653f93e627.png)

继续插入“120”，直接添加的结果如下图，此时超过了节点可以存放容量，对于四阶B树每个节点最多存放3个值，此时需要执行分裂操作

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/9b620598164d40ad8541edc2e44e3d0d.png)

分裂操作为，先选取待分裂节点的中值，这里为“60”，然后将中值“60”放到父节点中，因为这里还没有父节点，那么直接创建一个新的父节点存放“60”，而原来小于“60”的那些值作为左子树，原来大于“60”的那些值作为右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/0614ecc3aa7f4fce819be130968921d9.png)

继续插入“95”，因为比“60”大，放到右子树中，

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/356af87764bb48f6bcaa742dae5963d3.png)

继续插入“200”，因为比“60”大，放到右子树中

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d5afc2f09e8c41a0b0c2109a2b8c4c91.png)

此时超过了节点可以存放容量，需要执行分裂操作， 找到“90 95 120 200”之间的中值“95”，然后将中值“95”放到父节点中，父节点中的“90”小于“95”，于是放到“90”右边，而原来小于“95”的那些值作为左子树，原来大于“95”的那些值作为右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/e877f3b741424a5e83166f5b654b906f.png)

继续插入10， 100

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/a1fd0d829a1d4ebcbca5c6bc2d0ebafb.png)

继续插入 300

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/1de484ededff4f35ab26ae05eebe1d33.png)

插入300后，需要执行分裂操作， 找到“100 120 200 300 ”的中值“300”，然后将中值“120”放到父节点中，父节点中的“60 95”小于“120”，于是放到最右边，而原来小于“120”的那些值作为左子树，原来大于“120”的那些值作为右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/5cc13a3bfb86434293a188cd7f5989ec.png)

继续插入500，600

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/0bbc3adc5ec5468da9426411961805b2.png)

插入600后，需要执行分裂操作， 找到“200  300  500 600”的中值“300”，然后将中值“300”放到父节点最右边，而原来小于“300”的那些值作为左子树，原来大于“300”的那些值作为右子树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/4a3c23763a654f7b858051f67fdc9a25.png)

根节点中元素个数超过了4， 选取根节点的中值“95”，然后将中值“95”放到父节点中，由于还没有父节点，那么直接创建一个新的父节点存放“95”，而原来小于“95”的那些值作为左子树，原来大于“95”的那些值作为右子树。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/e84c2d4903dd43dd9928cfcc9c169027.png)

插入250，比根节点大，往根节点的右子树遍历，因为右子树不是叶子节点，继续往下，因为250介于120和300之间，往第二个分支

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/a3594f84a2164d47a3196cffdec30afd.png)

继续插入700，800

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/6df741e866f44b159e61f0eb6d63d0b7.png)

插入800以后，第三个分支需要分裂

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/dd9f3181d47f466fb14ff6c61bda9c6c.png)

### 4.7.3 B树的查找

对B树进行查找就比较简单，查找过程有点类似二叉搜索树，从根节点开始查找，根据比较数值找到对应的分支，继续往子树上查找。

比如查找“250”，"250"大于“95”，往右子树，“250”介于“120 300”之间，往第二个分支，在第二个分支中可以找到250。

### 4.7.4 B树的应用

文件系统中对磁盘数据的存储：

我们知道，数据是存储在磁盘中的，计算机操作磁盘上的文件是通过文件系统进行操作的，在**文件系统中就使用到了B树这种数据结构**。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/7a8652c4596c438e89f3f61fe2014031.png)

磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开，这些间隙中不存储数据 。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/bbcc359c212b4fae9eae432c81efd1c3.png)

磁盘用磁头来读写存储在盘片表面的数据，由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘 I/O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I/O效率。

页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（一般为4096字节），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页，这样每个结点只需要一次I/O就可以完全载入。

这样设计有什么好处呢？

在实际设计中，我们把 **一个结点设为一个页** ，

## 4.8 B+树

### 4.8.1 B+树的基本概念

B+树是B树的升级。

* 不同于B树，B+树的非叶子节点不再保存关键字记录的指针，只进行数据索引
* B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取，所以每次查询效率一样
* 所有叶子结点都有一个指向右边叶子节点的指针
* 所有数据都保存在叶子结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d7ecb9ed5357495abafa04df698bb9f4.png)

### 4.8.2 B+树的插入

B+树的插入与B树类似。

下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。

1）空树中插入5

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/7cf75fb1cc414274b8261967aee84c0e.png)

2）依次插入8，10，15

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/3333b7e1859a450fb6a6566b2458c27f.png)

3）插入16

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/6ab3342f687141ccb8fb17ce0522e78b.png)

插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录。结果如下图所示：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/cb45e053991c4178bb4e83e02bfd9c51.png)

当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录。

4）插入17， 18

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/5dc63e790dbf4a1fa63d38bc61953c70.png)

插入18后关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/ee2234d3f76947f4b9953fe7135b7bbd.png)

5）插入若干数据后

* 插入6

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/346dd5439dea46c4bc83ca6d43c8a91a.png)

* 插入9

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/4395015eba4b4fbd8f678b775bb7fc39.png)

* 插入19

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/47be364668e24aeeb7269d3f38efc881.png)

* 插入20

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/780584a477f5465e9f27c69e981dda57.png)

* 插入20后需要进行分裂

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/fdfa74a775834a4988ca32f544dfe794.png)

* 插入21

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d76370e8686a4526b1cb37ac8575a3fc.png)

* 插入22

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/50550d1e65764e319ee904f9148cc283.png)

* 插入22后分裂

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/8040efbfe4cb4e04b7cc9e030ddf7b6b.png)

* 插入7

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/6b873b7eb81b4dddbd56966c1b61a31e.png)

* 插入7后需要分裂

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/3f478237f89547729b0dd22cd7dd9f32.png)

* 根结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/b033910b5397462e882d23a933fbedaa.png)

### 4.8.3 B+树的应用

Mysql数据库中使用B+树做索引：

在对数据库进行查询时，我们可能经常会使用类似如下查询语句：select  name from table where ID >=80 and ID &#x3c;=90，去查找某个区间的内容。

因为B+树的所有叶子节点是一种链式结构，因此在查找80到90之间的所有数据时，我们只需要找到80，然后沿着链表往后遍历即可找到80到90之间的所有数据。

思考：如果使用B树做索引效率比B+树高还是低呢？

## 4.9 哈希表

### 4.9.1 哈希表的引入

* 思考1：假如使用一种数据结构存储全校学生的相关信息，请问如何迅速查找到该学生？
* 思考2：我们在应用程序开发过程中会定义很多的变量和函数，当编译器编译完后，会给某些变量和函数在内存中分配地址，程序在运行的时候是如何快速访问到这些变量和函数的呢？

### 4.9.2 哈希表的概念

* 我们必须先了解一种新的存储方式—**散列技术**： 散列技术是指在**记录的存储位置**和它的关键字（key）之间建立一个确定的对应关系f，**使每一个关键字都对应一个存储位置**。即：**存储位置=f（关键字）**。这样，在查找的过程中，只需要通过这个对应关系f 找到给定值key的映射f（key），得到对应的存储位置，再将对应存储位置中存储的关键字和需要查找的关键字进行比较即可。
* 我们把这种对应关系f 称为**散列函数**或**哈希函数**。![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/d4f3b4717e0b4d58ad9abcb168a6688f.png)
* 按照这个思想，采用散列技术**将记录存储在一块连续的存储空间中**，**这块连续的存储空间称为哈希表**。所得的存储地址称为哈希地址或散列地址。
  * **数据的哈希地址=f（关键字的值）**
* 通过关键字求哈希地址的过程称之为：**哈希**

### 4.9.3 哈希表的本质

* 哈希表的本质：**数组** 。
* 通过哈希函数得到的哈希地址（哈希值）其实就是数组的下标或者索引。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/df0375b11e9c49938ac2ec4fb898c1bd.png)

### 4.9.4 哈希函数的构造方法

#### 4.9.4.1 哈希**函数的构造的原则**

* 计算简单：哈希函数不应该有很大的计算量，否则会降低查找效率。
* 分布均匀：哈希函数值即散列地址，要尽量均匀分布在地址空间，这样才能保证存储空间的有效利用并减少冲突。

#### 4.9.4.2 直接定址法

哈希函数是关键字值的线性函数，即：h(key) = a * key + b （a，b为常数）

* 假设需要统计中国人口的年龄分布，以10为最小单元。今年是2018年，那么10岁以内的分布在2008-2018，20岁以内的分布在1998-2008……假设2018代表2018-2008直接的数据，那么关键字应该是2018，2008，1998……
  * 那么可以构造哈希函数H（key）=（2018-key）/10
  * 那么hash表建立如下：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/c05acd80912d4f2c9ff0a5373227d0b5.png)

#### 4.9.4.3 除留余数法

设有一组关键字，试用除留余数法求设计哈希函数。关键字组：（19,14,23,01,68,20,84,27,55,11,10,79,12,39,21）。
可以设置为H(key)=key%13；为什么取13？我们可以假设它取9，得出的余数分别为1 5 5 1 5 2 3 0 1 2 1 7 3 3 3。可以看出1 3 5的余数非常多，当它映射到存储地址时，会更容易的造成冲突。所以我们在选择取余数时，一般取**质数**，让它的冲突尽可能的少。

#### 4.9.4.4 数字分析法

如果关键字由多位字符或者数字组成，就可以考虑抽取其中的 2 位或者多位作为该关键字对应的哈希地址，在取法上尽量选择变化较多的位，避免冲突发生。

例如下表中列举的是一部分关键字，每个关键字都是有 8 位十进制数组成：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/591e1b2ecdc0408b849cc6394bce37e4.png)

通过分析关键字的构成，很明显可以看到关键字的第 1 位和第 2 位都是固定不变的，而第 3 位不是数字 3 就是 4，最后一位只可能取 2、7 和 5，只有中间的 4 位其取值近似随机，所以为了避免冲突，可以从 4 位中任意选取 2 位作为其哈希地址。

#### 4.9.4.5 折叠法

是将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。此方法适合关键字位数较多的情况。

例如，在图书馆中图书都是以一个 10 位的十进制数字为关键字进行编号的，若对其查找表建立哈希表时，就可以使用折叠法。

若某书的编号为：0-442-20586-4，分割方式如图 1 中所示，在对其进行折叠时有两种方式：一种是移位折叠，另一种是间界折叠：

* 移位折叠是将分割后的每一小部分，按照其最低位进行对齐，然后相加，如图 1（a）；
* 间界折叠是从一端向另一端沿分割线来回折叠，如图 1（b）。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/3a6db0c6486d4391b7a810962d1b585c.png)

### 4.9.5 哈希冲突

在哈希函数的设计过程中，不管哈希函数设计的如何巧妙，总会有特殊的key导致哈希冲突。![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/adc19ff2771f45cba37bfc4b41020046.png)

解决哈希冲突主要有如下方法：

* **开放寻址法/开放定址法**
* **再哈希法**
* **拉链法/链地址法**
* **建立公共溢出区**

##### 4.9.5.1 开放寻址法

**1、开放寻址法的概念**

开放寻址法指的是：当哈希值p = H(key)出现冲突时，以p为基础，产生另一个哈希值，如果p1仍然冲突，再以p为基础，产生另一个哈希值p2，…，直到找到一个不冲突的还行值，表示为：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/5d31f18b252349bdb713f7ae8387e607.png)

其中H~0~表示第一次计算的哈希值，H~i~表示第i次计算的哈希值。m为数组的长度。di为增量序列，根据增量序列的取值不同，又分为三种：

* 线性探测法
  * d~i~ = 1，2，3，4，5，6，…，m-1， 这种方法是在发生冲突时，顺序查看表中的下一个单元，直到找出一个空单元或查遍全表。
* 二次探测法
  * d~i~ = 1 ^2^ ，-1 ^2^ ，2 ^2^ ，-2 ^2^ ，…(i = 1，2，3，4，…，(m-1)/2)， 这种方法在发生冲突时，在表的左右进行跳跃式探测，比较灵活。
* 伪随机探测法

**2、线性探测例题**

* 题目：
  * 已知一个线性表（38，25，74，63，52，48），假定采用散列函数h（key) = key%7计算散列地址，并散列存储在散列表A[7]中，采用线性探测方法解决冲突。
* 解题思路：
  * 线性表长度为6， 采用直接定址法， 与质数7取模
  * 进行38这个数据处理 ：38%7 = 3，直接把38放在下标为3的位置 ， {0, 0, 0, 38, 0, 0, 0}
  * 处理25, 25%7=4，一样把25放在下标为4的位置，{0, 0, 0, 38, 25, 0, 0}
  * 接下来是74， 74%7=4，可是这时候4上已经放了25了。得进行线性探测：
    * H(74) = 4;根据线性探测：D(i)=(H(i)+d)MOD M(M为散列表长度7)， d=1时候 D(1) = (4+1)%7=5散列表中5位置为空，因此能够把74放在位置5处
    * {0, 0, 0, 38, 25, 74, 0}
  * 接下来是63， 63%7=0直接把63放在0处， {63， 0, 0, 38, 25, 74, 0}
  * 接下来是52， 52%7=3可是位置3已经有38了冲突，得进行线性探测：
    * 线性探测：D（1）=（3+1）%7=4， 4上有25了， 冲突
    * D(2)=(3+2)%7=5， 5上有74了， 冲突
    * D(3) = (3+3)%7=6， 能够 把52放在6位置上
    * {63, 0, 0, 38, 25, 74, 52}
  * 接下来是48， 48%7=6， 6位置有52了， 冲突， 得进行线性探测：
    * D(1) =（6+1）%7=0，0上有63了，冲突
    * D(2)=(6+2)%7=1， 1上还没有数据， 能够放48
    * {63, 48, 0, 38, 25, 74, 52}

#### 4.9.5.2 再哈希法

再哈希法是同时构造多个不同的哈希函数，第一个冲突了用第二个，第二个也冲突了用第三个。

例如：实用哈希函数 H = x + b时产生了冲突，就使用H = 2x + b, 再冲突了就使用H = 3x + b 。。。，但是这种方法不是很实用，而且每次冲突都需要重新调用哈希函数，效率不高。

#### 4.9.5.3 拉链法（链地址法）

* 将所有产生冲突的关键字所对应的数据全部存储在同一个线性链表中。
* 例如有一组关键字为 `{19,14,23,01,68,20,84,27,55,11,10,79}`，其哈希函数为：`H(key)=key MOD 13`，使用链地址法所构建的哈希表如下图所示：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/402/1508267693852065792/5750d757f9ed4915ba62a079b9ae3c68.png)

#### 4.9.5.4 解决冲突的方法的总结

* 开放地址法：计算简单快捷，处理起来方便，但线性探测法容易形成“堆聚”。另外，该方法的删除操作显得十分复杂，我们不能直接删除关键字所在的记录，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经成了空地址，查找到这里时会终止查找。所以，就需要重建哈希表，特别浪费性能。
* 拉链法：该方法将所有哈希地址相同的结点构成一个单链表，单链表的头结点存在哈希数组里，链地址法常出现在经常插入和删除的情况下，此时，哈希表的插入/删除/查找都是O(1)的时间复杂度。该法不会出现“堆聚”现象，哈希地址不同的关键字不会发生冲突；不需要重建哈希表。另外，如果开放地址法中，哈希表里存满关键字了就需要扩充哈希表然后重建哈希表，而链地址法不需要。

### 4.9.6 哈希函数和哈希表的应用

**1、唯一标识**

举个例子，如果在海量的图库中，搜索一张图是否存在，我们不能单纯的用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但是图片内存不同，或者名称不同图片内存相同的情况。那我们该如何搜索呢？

* 我们知道，任何文件在计算中都可以表示成二进制串。所以，比较笨的方法是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 KB、大则几 MB，转换成二进制是一个非常长的串，比对起来非常耗时。有没有比较快的方法呢？
* 我们可以给每个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制串开头取10个字节，从中间取10个字节，从最后取10个字节，然后将这300个字节放在一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。
* 如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识
* 如果不存在，那就说明这个图片不再图库中；如果存在，我们在通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。

**2、数据校验**

我们知道，BT下载的原理是基于P2P协议的。我们从多个机器上并行下载一个2GB的电影，这个电影文件可能会被分隔成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。

我们知道，网络传输是不安全的，下载的文件块有可能是被宿主机恶意修改过的，又或者下载过程中出现了差错，所以下载的文件块可能不是完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电影中电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整呢？

思路：

* 我们通过哈希算法，对100个文件块分布取哈希值，并且保存在种子文件中
* 我们知道，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。
* 所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载号的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。

**3、如何统计“搜索关键词”出现的次数**

问题：假如我们有1T的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，应该怎么做呢？

这个问题主要有两个难点：

* 第一个是搜索日志很大，没办法放到一台机器的内存中
* 第二个是如果只用一台机器来处理这么大的数据，处理时间会很长。

那如何解决这两个难点呢？

* **我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度**

具体思路：

* 为了提高处理的速度，我们用 n 台机器并行处理。
* 我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n 取模，最终得到的值，就是应该被分配到的机器编号。
* 这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果

**4、何快速判断图片是否在图库中？**

如何快速判断图片是否在图库中？可以给即给每个图片取唯一标识（或者信息摘要），然后构建散列表。

假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。

* 我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。
* 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。

现在，我们来估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。

* 散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。
* 假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。

实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。

**5、C++ STL 中的 unordered_map**

因为内部实现了哈希表，因此其查找速度非常的快， 但是哈希表的建立比较耗费时间。

**6、Mysql的索引可以实用哈希表**

**7、Linux内核中的路由查找算法用到了哈希表**
